[{"title":"Select下拉列表实现","date":"2022-08-08T08:58:10.000Z","url":"/2022/08/08/Select%E4%B8%8B%E6%8B%89%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0/","tags":[["elementplus","/tags/elementplus/"]],"categories":[["前端框架","/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"],["elementplus","/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/elementplus/"]],"content":"以分类的表数据为例， 组件代码： 结果截图： "},{"title":"java练习四","date":"2022-08-08T01:25:00.000Z","url":"/2022/08/08/java%E7%BB%83%E4%B9%A0%E5%9B%9B/","tags":[["java","/tags/java/"]],"categories":[["java","/categories/java/"],["随笔","/categories/java/%E9%9A%8F%E7%AC%94/"]],"content":"1、try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行?，什么时候被执行，在return前还是后?【建议debug尝试下】 2.下面的程序代码输出的结果是多少？ 解：出现两个return，一定以finally为准 3、error和exception有什么区别? 4、sleep() 和 wait() 有什么区别? 5、当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法? 6、启动一个线程的方法是? 7、设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。写出程序。 以下程序使用内部类实现线程，对j增减的时候没有考虑顺序问题。 8、Collection 和 Collections的区别? 9、自己写个类，也叫java.lang.String有没有问题?有问题回答错,没有问题回答对 10、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？"},{"title":"elmPlus-Rate评分","date":"2022-08-04T11:56:21.000Z","url":"/2022/08/04/elmPlus-Rate%E8%AF%84%E5%88%86/","tags":[["elementplus","/tags/elementplus/"]],"categories":[["前端框架","/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"],["elementplus","/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/elementplus/"]],"content":" 后台： 即可实现评分操作， 前端部分可以是整数型数据，后台接收的数据是 int"},{"title":"java-day08","date":"2022-08-04T06:27:17.000Z","url":"/2022/08/04/java-day08/","tags":[["java","/tags/java/"]],"categories":[["java","/categories/java/"],["随笔","/categories/java/%E9%9A%8F%E7%AC%94/"]],"content":"集合含义容器,位于java.util包下面的类 数组特点 大小固定[不会自动扩容] 可以存基本数据、引用数据类型 集合特点 大小不固定[自动扩容] 只能存放引用数据类型 示意图 ArrayList含义是动态变长的数组 底层是动态变长的数组 体系结构 Collection List ArrayList 常用方法 isEmpty size add remove set contains get clear toArray addAll 将集合参数的元素逐个加入 removeAll 将集合参数中的元素中出现的逐个删除 containsAll 判断集合参数中的元素释放全部都存在 indexOf 获取元素第一次出现的位置 lastIndexOf 获取元素最后一次出现的位置 等等 泛型含义参数化类型(将操作的数据类型放到&lt;&gt;中) 好处 明确操作类型 避免强制转换 使用场景 类、接口 方法 案例一Animal.java GenericDemo.java 案例二 案例三User.java Student.java _03GenericDemo.java Vector含义线程安全的ArrayList,使用是上和ArrayList使用差不多 vs ArrayList 都实现List接口 底层都是采用可变数组存储 vector是线程安全的 体系结构 Collection List Vector 常用方法 add addAll remove removeAll contains containsAll set get isEmpty size indexOf lastIndexOf toArray clear 等等 案例 Stack含义栈数据结构 体系 Collection List Vector Stack 底层本质采用可变数组 常用方法 empty() push pop peek 案例 LinkedList含义JDK提供的类,该类实现双向链表数据结构 示意图 底层双向链表 体系结构 Collection List LinkedList 常用方法和ArrayList差不多 案例一 案例二 vs ArrayList ArrayList LinkedList 数据结构 数组 链表 是否有索引 有 没有 根据索引查询 快 慢(只能遍历后比较位置) 更新 快(通过索引快速找到更新) 慢(只能遍历找到后更新) 删除 慢(需要移动位置) 快(不需要移动位置) 添加 慢(需要移动位置) 快(不需要移动位置) 单向队列[了解]特点FIFO\\LILO 案例 双向队列[了解] HashMap 示意代码MyHashMap.java Test.java HashMap含义key-value形式 底层数组+链表 示意图 体系结构 Map HashMap 常用方法 size put putAll get size isEmpty clear containsKey containsValue remove 等等 案例一 案例二 案例三验证HashMap是否有序 LinkedHashMap含义有序的hashMap 体系结构 Map HashMap LinkedHashMap 案例 Hashtable含义重量级HashMap,用法和HashMap类似 体系结构 Map Hashtable 和HashMap的区别 Hashtable的方法几乎都有synchronized【线程安全】 HashMap的key和value都是可以为null,Hashtable的key和value都不可以为空 案例"},{"title":"java-day11","date":"2022-08-04T06:22:35.000Z","url":"/2022/08/04/java-day11/","tags":[["java","/tags/java/"]],"categories":[["java","/categories/java/"],["随笔","/categories/java/%E9%9A%8F%E7%AC%94/"]],"content":"转换流含义:字节流装成字符流 种类 InputSteamReader 将字节输入流转为字符输入流 OutputStreamWriter 将字节输出流转为字符输出流 案例一 案例二 序列化 &amp; 反序列化序列化 将对象转成二进制并保存到磁盘中 对象需要实现序列化接口 反序列化含义 将磁盘中的二进制对象加载到内存中 对象需要实现序列化接口 要求 包名序列化前后也要一样 实现Serializable接口 生成一个版本号 作用:用来校验类是否修改过 案例User.java Test.java 打印流含义可以输出任何类型的数据 注意点当打印对象的时候,只是输出了对象.toString()结果。并不是将整个对象输出。 种类 PrintStream PrintWriter [掌握] 案例User.java PrintTest.java 线程相关概念 串行 多个事件依次执行 并行 多个事件在同一时刻同时执行 并发 在一段时间内多个事件发生 进程 一个正在运行软件,一个软件对应一个进程 一个进程中至少有个一个线程 线程 是进程中的执行分支(索引) 进程和线程区别 每个进程都有独立的内存空间 一个进程至少要有一个线程 每创建一个线程都有自己的栈、本地方法区、程序计数器【TODO】 如何创建线程 继承Thread 实现Runnable接口 入门案例示意图 代码 常见的方法上 Thread.currentThread() 获取当前线程对象 start 启动线程【此时是就绪状态并不是说马上执行该线程的任务,而是需要等待获得cpu运行时】 run 指定线程的任务 getId 获取线程的id getName 获取线程的名称 setName 设置线程的名称,还可以在构造器中调用父类的super(String threadName) 案例 示意图 两种方式区别 实现方式可以共享资源,继承不可以共享资源 实现方式还可以继承其他类,继承方式不可以再继承其他类了 资源共享方式有线程安全问题 案例继承方式 实现接口方式 线程安全常见概念 线程安全 多线程修改操作同一份资源数据不会错乱 线程不安全 [线程安全问题] 多线程修改操作同一份资源带来的数据错乱。 处理方案 同步[监视对象] 同步方法 同步代码块 锁 案例一同步方法 案例二验证两个资源的监视对象不一样的时候,当线程1进入监视对象1的资源时,线程2是否可以进入监视对象2的资源? 结论可以 案例三同步代码块 案例四使用可重入锁 单例含义某个类在程序运行期间最多只能创建一个对象 方式 饿汉式 懒汉式 需要使用的时候才创建对象 枚举 懒汉式步骤 构造器private 对外提供获取实例的方法 注意里面要考虑线程安全的问题 代码ATM.java Test.java 常见方法下 isAlive setPriority getPriority isInterrupted interrupt 判断是否存活 线程优先级 线程中断"},{"title":"对synchronized的理解","date":"2022-08-03T10:37:52.000Z","url":"/2022/08/03/%E5%AF%B9synchronized%E7%9A%84%E7%90%86%E8%A7%A3/","tags":[["java","/tags/java/"]],"categories":[["java","/categories/java/"],["随笔","/categories/java/%E9%9A%8F%E7%AC%94/"]],"content":"​ 一旦一个包含锁定方法（用synchronized修饰）的线程被CPU调用，其他线程就无法调用相同对象的锁定方法。当一个线程在一个锁定方法内部，所有试图调用该方法的同实例的其他线程必须等待 synchronized：同步锁（互斥锁）：在java语言中，引入了同步锁的概念，每个对象都有一个与之关联的内部锁（排他锁），用以保证共享数据的安全性问题。 关键词synchronized用来给某个方法或某段代码加上一个同步锁。 当调用者调用此方法时，必须获得这把锁才可以调用。 当某个调用者获得这把锁之后，其他调用者就无法获得了。 当调用结束后，调用者释放这把锁，此时其他调用者才可以获得。 这个机制保障了某个同步方法同时只能有一个调用者。 synchronized 和 static synchronized的区别： 概述通过分析这两个用法的分析，我们可以理解java中锁的概念。一个是实例锁（锁在某一个实例对象上，如果该类是单例，那么该锁也具有全局锁的概念），一个是全局锁（该锁针对的是类，无论实例多少个对象，那么线程都共享该锁）。实例锁对应的就是synchronized关键字，而类锁（全局锁）对应的就是staticsynchronized（或者是锁在该类的class或者classloader对象上）。 区别1. synchronized关键字：synchronized作用是对类的当前实例（对象）加锁。可以使用synchronized关键字来标记一个方法或者代码块，当某个线程调用该对象的synchronized方法或者访问synchronized代码块时，这个线程便获得了该对象的锁，其他线程暂时无法访问这个方法，只有等待这个方法执行完毕或者代码块执行完毕，这个线程才会释放该对象的锁（Java 并发编程）。 2.synchronized代码块【synchronized（synObject）】使用起来比synchronized方法要灵活得多。因为也许一个方法中只有一部分代码只需要同步，如果此时对整个方法用synchronized进行同步，会影响程序执行效率。而使用synchronized代码块就可以避免这个问题（同步对象或类属性），synchronized代码块可以实现只对需要同步的地方进行同步。 3. 与Lock的区别： synchronized是Java语言的关键字，因此是内置特性，Lock是一个类（java.util.concurrent.locks包），通过这个类可以实现同步访问； synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用。Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。 4. static synchronized：​ 每个类有一个锁，它可以用来控制对static数据成员的并发访问。访问static synchronized方法占用的是类锁，而访问非static synchronized方法占用的是对象锁。 ​ static synchronized控制类的所有实例（对象）的访问（相应代码块）。synchronized相当于 this.synchronized，static synchronized相当于Something.synchronized 案例：一个日本作者-结成浩的《java多线程设计模式》有这样的一个列子： ​ 那么，假如有Something类的两个实例x与y，那么下列各组方法被多线程同时访问的情况是怎样的？ a. x.isSyncA()与x.isSyncB() b. x.isSyncA()与y.isSyncA() c. x.cSyncA()与y.cSyncB() d. x.isSyncA()与Something.cSyncA() 这里，很清楚的可以判断： ​ 都是对同一个实例（x）的synchronized域访问，因此不能被同时访问。（多线程中访问x的不同synchronized域不能同时访问) ​ 如果在多个线程中访问x.isSyncA()，因为仍然是对同一个实例，且对同一个方法加锁，所以多个线程中也不能同时访问。（多线程中访问x的同一个synchronized域不能同时访问) ​ 是针对不同实例的，因此可以同时被访问（对象锁对于不同的对象实例没有锁的约束） ​ 因为是static synchronized，所以不同实例之间仍然会被限制,相当于Something.isSyncA()与 Something.isSyncB()了，因此不能被同时访问。 ​ 书上的答案是可以被同时访问的，答案理由是synchronzied的是实例方法与synchronzied的类方法由于锁（lock）不同的原因。 ​ 个人分析也就是synchronized 与static synchronized 相当于两帮派，各自管各自，相互之间就无约束了，可以被同时访问。 举个例子： 测试结果： 上面代码synchronized同时修饰静态方法和实例方法，但是运行结果是交替进行的，这证明了类锁和对象锁是两个不一样的锁，控制着不同的区域，它们是互不干扰的。同样，线程获得对象锁的同时，也可以获得该类锁，即同时获得两个锁，这是允许的。 结论:A: synchronized static是某个类的范围，synchronized static cSync{}防止多个线程中多个实例同时访问这个类中的synchronized static 方法。它可以对类的所有对象实例起作用。 B: synchronized 是某实例的范围，synchronized isSync(){}防止多个线程中这一个实例同时访问这个类的synchronized 方法。 其实总结起来很简单。 一个锁的是类对象，一个锁的是实例对象。 若类对象被lock，则类对象的所有同步方法全被lock； 若实例对象被lock，则该实例对象的所有同步方法全被lock。"},{"title":"集合练习","date":"2022-08-02T12:21:07.000Z","url":"/2022/08/02/%E9%9B%86%E5%90%88%E7%BB%83%E4%B9%A0/","tags":[["java","/tags/java/"]],"categories":[["java","/categories/java/"],["随笔","/categories/java/%E9%9A%8F%E7%AC%94/"]],"content":"1、请使用LinkedList来模拟一个队列(先进先出的特性):1.1 拥有放入对象的方法void put(Object o) 1.2 取出对象的方法Object get() 1.3 判断队列当中是否为空的方法boolean isEmpty()；并且，编写测试代码，验证你的队列是否正确。 主程序： 测试结果： 3、在一个列表中存储以下元素：apple,grape,banana,pear3.1、 返回集合中的最大的和最小的元素 3.2 将集合进行排序，并将排序后的结果打印在控制台上 输出： 4、编写一个程序，创建一个 HashMap对象，用于存储银行储户的信息(其中储户的主要信息有储户的ID，姓名和余额)。另外，计算并显示其中某个储户的当前余额。 测试结果： 5、从控制台输入若干个单词（输入回车结束）放入集合中，将这些单词排序后（忽略大小写）打印出来。 测试结果： 6、[ 单选题 ]Java 中的集合类包括 ArrayList、LinkedList、HashMap 等类，下列关于集合类描述错误的是( C ) A: ArrayList 和 LinkedList 均实现了 List 接口 B ArrayList 的访问速度比 LinkedList 快 C 添加和删除元素时，ArrayList 的表现更佳 D HashMap 实现 Map 接口，它允许任何类型的键和值对象，并允许将 null 用作键或值 7.简答题：简单叙述一下 Arraylist扩容 与 hashmap 扩容机制 ？ ArrayList是将原数组copy到另一个新扩容的数组里，hashmap是通过单向链表进行扩容的。"},{"title":"IO输入输出流练习","date":"2022-08-02T12:19:06.000Z","url":"/2022/08/02/IO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E7%BB%83%E4%B9%A0/","tags":[["java","/tags/java/"]],"categories":[["java","/categories/java/"],["随笔","/categories/java/%E9%9A%8F%E7%AC%94/"]],"content":"1.拷贝一张 照片 从C 盘根目录到 D 盘根目录 (使用 处理流 实现 ) 2.拷贝一张 照片 从C 盘根目录到 D 盘根目录 (使用 节点流 实现 ) 3.创建文件 Demo1.txt 写入文本 hello 创建文件 Demo2.txt 写入文本 Neuedu,将两个文件内容 提取出来输出到 第三个文件 Test.txt 通过 文件与流方式实现FileUtil.java 工具类 WorkDemo1.java 主入口 4.在本机的磁盘系统中，找一个文件夹，利用File类的提供方法，列出该文件夹中的所有文件的文件名和文件的路径，执行效果如下：[必做题]"},{"title":"IO输入输出流","date":"2022-08-02T12:15:10.000Z","url":"/2022/08/02/IO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/","tags":[["java","/tags/java/"]],"categories":[["java","/categories/java/"],["随笔","/categories/java/%E9%9A%8F%E7%AC%94/"]],"content":"File含义File对象表示一个文件或文件夹 常用方法 pathSeparator pathSeparatorChar separator separatorChar new File(String pathName) new File(String parentName,String childName) new File(File parentFile,String childName) mkdir mkdirs createNewFile delete 删除普通文件或空目录 renameTo exists isFile isDirectory getParent getParentFile getAbsolutePath list listFiles 案例一 案例二创建、删除 案例三 案例四 案例五 IO含义输入输出流 分类 流向 输入 输出 传输单位 字节 字符 使用场景 读取配置文件 等等 字节流含义传输单位一个一个字节 使用场景操作非文本文件 mp3、mp4、压缩文件等等 分类 字节输出流 字节输入流 字节流输入流体系结构 InputStream FileInputStream 常用方法 new FileInputStream(String path) new FileInputStream(File file) read() 读取一个字节,-1代表读取到了末尾 read(byte [] cache) 读取到的字节放入到cache中 close 关闭管道 案例一 案例二使用缓冲 字节输入缓冲流含义字节缓冲输入流 常用方法 read close 示意图 案例 字节输出流含义字节输出流 体系结构 OutputStream FileOutputStream 常用方法 new FileOutputStream(Strint fileName) new FileOutputStream(File file) write close 案例 字节输出缓冲流含义对字节输出流的包装,内置有缓冲区。 常用方法 write flush 将缓冲区的数据输出到目标中 close 案例 字节流文件复制思路一边读取一边输出 代码StringUtil.java ParamException.java FileUtil.java 字符流含义传输单位一个一个字符 使用场景操作文本文件 txt\\xml\\html\\properties等等 分类 字符输出流 字符输入流 字符输入流含义字符输入流 体系结构 Reader FileReader 案例 字符输出流含义字符输出流 体系结构 Writer FileWriter 案例 字符流文件复制 代码行数统计 文件下载 Properties含义加载配置文件的 体系结构 Map Hashtable Properties 作用 读取配置文件其实就是properties文件 避免硬编码 硬编码意思是将软件的配置信息写死在java代码中,修改麻烦。 使用步骤 在资源文件夹下新建xx.properties文件 建议:新建名字为config的资源文件夹 往里面添加数据 key1&#x3D;value2 keyN&#x3D;valueN 通过IO读取该配置文件中的内容 案例"},{"title":"Comparable和Comparator区别","date":"2022-08-01T12:35:59.000Z","url":"/2022/08/01/Comparable%E5%92%8CComparator%E5%8C%BA%E5%88%AB/","categories":[["undefined",""]]},{"title":"单例模式","date":"2022-07-30T08:28:42.000Z","url":"/2022/07/30/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","tags":[["设计模式","/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"]],"categories":[["设计模式","/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"]],"content":"博客：  github： "},{"title":"HashMap原理学习","date":"2022-07-30T06:43:20.000Z","url":"/2022/07/30/HashMap%E5%AD%A6%E4%B9%A0/","tags":[["java","/tags/java/"]],"categories":[["java","/categories/java/"],["随笔","/categories/java/%E9%9A%8F%E7%AC%94/"]],"content":"HashMap 示意代码MyHashMap.java 模拟实现源码 Test.java 过程： 计算key的哈希code值，就能确定存放在数组中的位置。 然后判断这个位置是否有数据。 有两种情况：其一是没有数据，直接放入[value, key, ,hash]; 其二：有，将当前的key和原来位置的key调用equal方法比较，为true就使用newValue替换，为false就作为原来位置数据的next节点。 HashMap底层实现原理及面试问题①HashMap的工作原理 ​ HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，然后找到bucket位置来储存值对象。当获取对象时，通过键对象的 equals() 方法找到正确的键值对，然后返回值对象。 ​ HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。 ​ 当两个不同的键对象的hashcode相同时会发生什么？ 它们会储存在同一个bucket位置的链表 HashMap​ HashMap实现了Map接口，Map接口对键值对进行映射。Map中不允许重复的键。Map接口有两个基本的实现，HashMap和TreeMap。 含义key-value形式 底层数组+链表 示意图 体系结构 Map HashMap 常用方法 size put putAll get size isEmpty clear containsKey containsValue remove 等等 案例一 案例二 案例三验证HashMap是否有序 LinkedHashMap含义有序的hashMap 体系结构 Map HashMap LinkedHashMap 案例 Hashtable含义重量级HashMap,用法和HashMap类似 体系结构 Map Hashtable 和HashMap的区别 Hashtable的方法几乎都有synchronized【线程安全】 HashMap的key和value都是可以为null,Hashtable的key和value都不可以为空 案例 面试题：“你知道HashMap的工作原理吗？” “你知道HashMap的get()方法的工作原理吗？” ​ 但一些面试者可能可以给出答案，“HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。 ​ 当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。”这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Entry。 ​ 这一点有助于理解获取对象的逻辑。如果你没有意识到这一点，或者错误的认为仅仅只在bucket中存储值的话，你将不会回答如何从HashMap中获取对象的逻辑。这个答案相当的正确，也显示出面试者确实知道hashing以及HashMap的工作原理。 下个问题可能是关于HashMap中的碰撞探测(collision detection)以及碰撞的解决方法： “当两个对象的hashcode相同会发生什么？” 答：他们有equals()和hashCode()两个方法，并且两个对象就算hashcode相同，但是它们可能并不相等。因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。 ”这个答案非常的合理，虽然有很多种处理碰撞的方法，这种方法是最简单的，也正是HashMap的处理方法。但故事还没有完结，面试官会继续问： “如果两个键的hashcode相同，你如何获取值对象？” ​ 面试者会回答：当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，然后获取值对象。面试官提醒他如果有两个值对象储存在同一个bucket，他给出答案:将会遍历链表直到找到值对象。面试官会问因为你并没有值对象去比较，你是如何确定确定找到值对象的？除非面试者直到HashMap在链表中存储的是键值对，否则他们不可能回答出这一题。 其中一些记得这个重要知识点的面试者会说，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。完美的答案！ 许多情况下，面试者会在这个环节中出错，因为他们混淆了hashCode()和equals()方法。因为在此之前hashCode()屡屡出现，而equals()方法仅仅在获取值对象的时候才出现。 ​ 一些优秀的开发者会指出使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生，提高效率。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。 ​ 如果你认为到这里已经完结了，那么听到下面这个问题的时候，你会大吃一惊。 “如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？” 除非你真正知道HashMap的工作原理，否则你将回答不出这道题。默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。 如果你能够回答这道问题，下面的问题来了： “你了解重新调整HashMap大小存在什么问题吗？” 你可能回答不上来，这时面试官会提醒你当多线程的情况下，可能产生条件竞争(race condition)。 当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。 如果条件竞争发生了，那么就死循环了。这个时候，你可以质问面试官，为什么这么奇怪，要在多线程的环境下使用HashMap呢？） HashMap底层实现原理及面试问题： "},{"title":"字符串-Date-UUID-BigDecimal","date":"2022-07-28T11:17:39.000Z","url":"/2022/07/28/%E5%AD%97%E7%AC%A6%E4%B8%B2-Date-UUID-BigDecimal/","tags":[["java","/tags/java/"]],"categories":[["java","/categories/java/"],["随笔","/categories/java/%E9%9A%8F%E7%AC%94/"]],"content":"String 补充转换示意图 案例 StringBuilder含义可变字符串 使用场景做字符串拼接等操作 常用方法 new StringBuilder() new StringBuilder(CharSequence data) append insert deleteCharAt reverse 等等大量和String差不多 案例 StringBuffer含义线程安全的可变字符串 特点 方法几乎都加了synchronized,代表多线程环境下是线程安全的 其他方法几乎和StringBuilder一样 案例 Date含义日期类 常用方法 new Date() after before compareTo getTime setTime 案例 Calendar含义日期的操作类 常用方法 Calendar.getInstance() getTime setTime before after compareTo add(int field,int value) get(int field) 案例 SimpleDateFormat含义日期的格式化类 常用方法 applyPattern format parse 常见的格式 案例 UUID含义随机数 使用场景数据库主键(char(32)) 案例 享元设计模式含义将那些经常使用的对象缓存起来,使用的时候直接从缓存中获取 目的避免反复创建那些经常使用的对象 步骤 定义一个缓存容器[比如:数组] 静态代码块中创建那些经常使用的对象并放入缓存容器中 对外提供从容器中获取对象的方法 案例User.java Test.java 包装数据类型含义8大基本数据类型都有对应的引用数据类型,这些引用数据类型一般称为包装数据类型 为什么需要有 包装数据类型可以表示某些特定的状态 包装数据类型提供了一些好用的方法 对应关系 基本数据类型 包装数据类型 byte Byte short Short char Character int Integer long Long float Float double Double boolean Boolean 装箱自行不全 拆箱自行补全 常用方法 intValue valueOf parseInt toBinaryString toHexString max min compareTo MAX_VALUE MIN_VALUE SIZE 案例一 案例二 案例三 Sysetem[了解]含义 案例 Runtime[了解]含义 案例 BigDecimal含义用来表示任意精度的小数,常用在金额、高精度仪器 注意点 常用方法 new BigDecimal(String value) add 加法 subtract 减法 multiply 乘法 divide 除法 setScale 四舍五入 案例 BigInteger含义无限大的整数 案例TODO DecimalFormat含义数字格式化 案例TODO 集合含义容器,位于java.util包下面的类 数组特点 大小固定[不会自动扩容] 可以存基本数据、引用数据类型 集合特点 大小不固定[自动扩容] 只能存放引用数据类型 示意图 ArrayList含义是动态变长的数组 底层是动态变长的数组 体系结构 Collection List ArrayList 常用方法 isEmpty size add remove set contains get clear toArray … 案例 String的equals 跟equalsIgnoreCase区别?1、使用equals( )方法比较两个字符串是否相等。它具有如下的一般形式： boolean equals(Object str) 这里str是一个用来与调用字符串（String）对象做比较的字符串（String）对象。如果两个字符串具有相同的字符和长度，它返回true，否则返回false。这种比较是区分大小写的。 2、为了执行忽略大小写的比较，可以调用equalsIgnoreCase( )方法。当比较两个字符串时，它会认为A-Z和a-z是一样的。其一般形式如下： boolean equalsIgnoreCase(String str) 这里，str是一个用来与调用字符串（String）对象做比较的字符串（String）对象。如果两个字符串具有相同的字符和长度，它也返回true，否则返回false。"},{"title":"springboot全局异常处理","date":"2022-07-27T11:24:11.000Z","url":"/2022/07/27/springboot%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","tags":[["springboot2","/tags/springboot2/"]],"categories":[["springboot","/categories/springboot/"],["springboot2","/categories/springboot/springboot2/"]],"content":"方法一：CodeMsg.java GlobalExceptionHandler.java Result.java 方法二：Result.java BaseErrorInfoInterface.java CommonEnum.java BizException.java GlobalExceptionHandler.java 注： return Result.error(CommonEnum.NO_KNOW_ERROR); &#x2F;&#x2F; 枚举类是BaseErrorInfo接口的具体子类，所以这里可以写接口实现类的参数 测试："},{"title":"java04","date":"2022-07-27T01:45:42.000Z","url":"/2022/07/27/java04/","tags":[["java","/tags/java/"]],"categories":[["java","/categories/java/"],["随笔","/categories/java/%E9%9A%8F%E7%AC%94/"]],"content":"变量含义分类 局部变量 成员变量 实例变量【对象级别】 类变量 【类级别】 static含义修饰成员变量、方法代表类级别 可以直接通过类名.调用 语法 修饰符成员变量 多个对象共享一个变量 修饰方法 一般作为工具类,方便调用 注意点 static修饰的方法可以访问 static修饰的成员变量 static修饰的方法 static修饰的方法可以不可以访问 非static修饰的成员变量 非static修饰的方法 非static修饰的方法可以访问 static修饰的成员变量 static修饰的方法 非static修饰的成员变量 非static修饰的方法 static方法里面不可以使用this关键字 总结:静态只能访问静态的 案例一static修饰成员变量 _01staticDemo.java 案例二static修饰方法 CommonUtil.java _02staticMethod.java GC含义Grabage Collection,是后台运行级别比较低的线程,定时释放堆内存。 作用 回收没有被引用、超过作用范围的对象 注意点 当一个对象被回收的时候会先执行它的finalize方法 调用System.gc()方法可以触发GC执行一次工作 案例 对象比较 &#x3D;&#x3D; equals TODO instanceOf 案例 构造器含义用来创建并返回对象的 在创建对象的时候可以初始化对象的成员变量信息 语法 默认的无参构造器含义当一个类没有显示指定构造器的时候默认会有一个无参构造器 语法 特点 没有参数 范围修饰符和类的一样【TODO】 如果显示给了默认的则无效 工作 如果给了有参构造器后,一般都会显示的给个无参构造器 案例 package含义包,在磁盘中其实就是文件夹 用途 java源文件的归类【或者说划分类,将功能同类的类放到相同包下】 避免java文件名冲突 特点 在文件系统中其实就是文件夹 在java源文件的第一行出现package 所在包名; 在java源文件只能存在一个package 语句 规范 公司域名倒写.项目名.模块名 全部小写 如果数字开头需要添加_ 层级显示 常见包名 java.util JDK提供的工具类 java.awt GUI java.lang 比如:String、Math、Exception 不用去导入的,自动导入了 java.sql 数据库相关的 java.net 网络相关的 java.io IO相关的 Import含义导入【用来引用在哪个包中的类】 ctrl + shift + o &#x2F;&#x2F;导入需要的，删除不需要的 常见语法 import 包名.类名; 引用指定包名下的类 import 包名.*; 引用指定包下的所有类 继承含义 子类拥有父类的属性、方法 子类根据需求扩展 可以对继承下来的方法进行重写[TODO] 增加其他字段和方法 语法 使用场景提取共性到父类,再使用继承 注意点 java中的类属于单继承 好处 使编码更高效 易维护 方便扩展 代码的重用、避免重复编写代码 ….. 案例Animal.java Cat.java Dog.java 数据类型转换 基本数据类型转换 自行回顾 引用数据类型转换 自动转换 [子赋值父] 强制转换 什么情况使用:父类型的对象 赋值 给子类型对象的时候 语法:(目标类型) 待强转对象 常见错误 ClassCastException 如何避免:使用instanceof先判断 案例Animal.java Cat.java Dog.java Test.java 封装含义 隐藏字段、方法实现细节 根据需求对外提供方法字段的方法 setter getter 如何实现范围修饰符做到的 种类各位同学自行编写代码去测试 种类 当前类 相同包 子类不同包 非子类不同包 private y n n n 默认 y y n n protected y y y n public y y y y 通常做法 全部字段私有,根据情况对外提供setter和getter 如果方法只能在当前类中使用的,就把该方法设置私有【通俗点就是能满足要求情况下范围修饰符越小越好】 案例Test.java User.java super含义父对象 使用场景 子类调用父类的构造器 TODO 子类调用父对象的方法 子类调用父对象的字段 案例User.java Work.java 方法重写含义当父类的方法不满足子类要求的时候可以重写方法 语法 可以这样理解,复制父类需要重写的方法到子类中,然后在方法上面添加@Override关键字 注意点 返回的范围修饰符要大于等于父类方法的 不能抛出比父类更大的异常 不理解没关系,后面学习异常之后会重写写案例的 static是不能重写 案例Animal.java Bird.java "},{"title":"新闻头条案例","date":"2022-07-27T01:24:04.000Z","url":"/2022/07/27/%E6%96%B0%E9%97%BB%E5%A4%B4%E6%9D%A1%E6%A1%88%E4%BE%8B/","tags":[["Vue3","/tags/Vue3/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"],["Vue3","/categories/%E5%89%8D%E7%AB%AF/Vue3/"]],"content":"一：Vue文件vue.config.js 注： target: ‘;, 地址 App.vue TopNews.vue TypeNews.vue NewsList.vue 二、setup语法糖vue.config.js App.vue TopNews.vue TypeNews.vue NewsList.vue"},{"title":"java多线程","date":"2022-07-26T06:49:01.000Z","url":"/2022/07/26/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/","tags":[["java","/tags/java/"]],"categories":[["java","/categories/java/"],["随笔","/categories/java/%E9%9A%8F%E7%AC%94/"]],"content":"1.1 进程和线程​ 进程process：每个进程都有独立的代码和数据空间，进程间的切换会有较大的开销，一个进程包含1-n个线程。可以把进程简单理解为操作系统中运行的一个程序。 ​ 线程thread：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。 ​ 多进程是指操作系统能同时运行多个任务（程序）。 ​ 多线程是指在同一个程序中多个顺序流在执行，进程是线程的容器，一个进程里可以运行1-N个线程，操作系统以进程为单位分配资源。 线程是进程的一个执行分支。 1.2 实现线程的方式​ 创建线程就是创建Thread类（子类）的对象（实例） ​ java.lang.Thread public class Thread extends Object implements Runnable 构造方法摘要 Constructor and Description Thread() : 分配一个新的 Thread对象。 Thread(Runnable target) : 分配一个新的 Thread对象。 创建一个新的执行线程有两种方法 :1.2.1 继承Thread类 一个是将一个类声明为Thread的子类。 这个子类应该重写run类的方法Thread 。 然后可以分配并启动子类的实例。 例如， 注意：主函数使用start方法启动新线程，而不是调用run方法 1.2.2 实现Runnable接口（优先使用） 另一种方法来创建一个线程是声明实现类Runnable接口。 那个类然后实现了run方法。 然后可以分配类的实例，在创建 Thread 时作为参数传递，并启动。 这两种方式的区别： 1、继承Thread类：编写简单，可直接操作线程。适用于单继承 2、实现Runnable接口：避免单继承局限性，便于共享资源。 推荐使用实现Runnable接口方式创建线程 思考：为什么不直接调用run()方法？ ​ 不管调用什么方法，如何调用，都是只有主线程一条执行路径。"},{"title":"天行数据API调用","date":"2022-07-25T09:16:20.000Z","url":"/2022/07/25/%E5%A4%A9%E8%A1%8C%E6%95%B0%E6%8D%AEAPI%E8%B0%83%E7%94%A8/","tags":[["Vue3","/tags/Vue3/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"],["Vue3","/categories/%E5%89%8D%E7%AB%AF/Vue3/"]],"content":"云音乐热评:  WYYun.vue 接口调用结果格式： "},{"title":"Vuex使用","date":"2022-07-25T01:57:18.000Z","url":"/2022/07/25/Vuex%E4%BD%BF%E7%94%A8/","tags":[["Vue3","/tags/Vue3/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"],["Vue3","/categories/%E5%89%8D%E7%AB%AF/Vue3/"]],"content":"1.在Vue-cli中的Vuex​ 在src文件夹中会出现一个store文件夹，此文件夹中有一个index.js文件，这就是Vuex模块的js文件。 2.Vuex的使用Vuex中有五个默认的基本对象： state: state就是Vuex中的公共的状态, 可以将state看作是全局唯一的共享数据仓库。 类似Vue中的data。（state是所以组件共享的；data是某个组件独有的。） getters: state 的计算属性，类似Vue中的computed 计算属性。 mutations：声明方法，用于修改state。类似Vue中的mothods方法。（只能修改同步数据）。 actions：声明方法，用于修改state。类似Vue中的mothods方法。（可以修改异步数据）。比如调用api接口都在这里完成。 modules：store的子模块，只在开发大型项目的时候会用的上。 3.在Composition API中使用Vuex。 先import导入useStore模块。 通过useStore模块获取store对象。就可以通过store对象获取Vuex中的所有数据了。 "},{"title":"组合式API","date":"2022-07-22T03:15:17.000Z","url":"/2022/07/22/%E7%BB%84%E5%90%88%E5%BC%8FAPI/","tags":[["Vue3","/tags/Vue3/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"],["Vue3","/categories/%E5%89%8D%E7%AB%AF/Vue3/"]],"content":"2.1.setup()入口 理解：Vue3.0中一个新的配置项，值为一个函数。 setup是所有Composition API（组合API）“ 表演的舞台 ”。 组件中所用到的：数据、方法等等，均要配置在setup中。 setup函数的两种返回值： 若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！） 若返回一个渲染函数：则可以自定义渲染内容。（了解） 注意点： 尽量不要与Vue2.x配置混用 Vue2.x配置（data、methos、computed…）中可以访问到setup中的属性、方法。 但在setup中不能访问到Vue2.x配置（data、methos、computed…）。 如果有重名, setup优先。 setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合） 2.2.ref 响应式监听2.3.reactive与toRefs2.4.computed的用法2.5.watch的用法 2.6.setup()参数​ setup() 函数有两个参数：props 和 context。 ​ 为什么要有这两个参数呢？我们知道父子组件之间是可以传值。但是现在我们的业务逻辑都写在setup函数中，而setpu中没有this指针，那么就只能靠这两个参数来进行传递了。 props：父组件向子组件传值的参数。 context：子组件向父组件传值的参数。 2.6.1.props参数setup() 函数的 props 是父组件向子组件传值的参数。 在components文件夹中创建子组件（Hello.vue）： 测试：父组件Home.vue 子组件Hello.vue 注：在父组件定义的路由可以查看父组件赋值给子组件的数据，但在子组件没数据。组件嵌套 结果截图： 2.6.2 context参数setup() 函数的 context 是子组件向父组件传值的参数。 父组件homeView.vue 子组件Hello.vue 2.7 ref函数 作用: 定义一个响应式的数据 语法: 创建一个包含响应式数据的引用对象（reference对象，简称ref对象）。 JS中操作数据： xxx.value 模板中读取数据: 不需要.value，直接：&lt;div&gt;&lt;/div&gt; 备注： 接收的数据可以是：基本类型、也可以是对象类型。 基本类型的数据：响应式依然是靠Object.defineProperty()的get与set完成的。 对象类型的数据：内部 “ 求助 ” 了Vue3.0中的一个新函数—— reactive函数。 2.8 reactive函数 作用: 定义一个对象类型的响应式数据（基本类型不要用它，要用ref函数） 语法：const 代理对象= reactive(源对象)接收一个对象（或数组），返回一个代理对象（Proxy的实例对象，简称proxy对象） reactive定义的响应式数据是“深层次的”。 内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。 2.9 reactive对比ref 从定义数据角度对比： ref用来定义：基本类型数据。 reactive用来定义：对象（或数组）类型数据。 备注：ref也可以用来定义对象（或数组）类型数据, 它内部会自动通过reactive转为代理对象。 从原理角度对比： ref通过Object.defineProperty()的get与set来实现响应式（数据劫持）。 reactive通过使用Proxy来实现响应式（数据劫持）, 并通过Reflect操作源对象内部的数据。 从使用角度对比： ref定义的数据：操作数据需要.value，读取数据时模板中直接读取不需要.value。 reactive定义的数据：操作数据与读取数据：均不需要.value。 ​ 在返回时使用 …toRefs(state) ，这样视图层就可以不使用 state 前缀了。 ​ 为什么要使用 … 参数扩展运输符呢？因为toRefs(state) 将state对象展开，并包装成多个响应数据。 3.Composition API的使用下面我们会将前面学过的知识点都改写为Composition API的形式。而且，Vue3兼容Options API和Composition API两种写法。所以这两种写法都要会。 3.1.provide与inject的使用​ 我们学过provide与inject可用于多级组件直接传递数据，下面学习provide与inject在Composition API中的使用。 示例： 创建孙子组件（SubHello.vue） 在子组件（Hello.vue）中使用孙子组件 在父组件中使用provide给多级组件传值 结果截图： 3.2.vue生命周期的用法在 setup () 内部调用生命周期钩子： 选项式API setup () 内部调用生命周期钩子 beforeCreate() setup() created() setup() beforeMount() onBeforeMount() mounted() onMounted() beforeUpdate() onBeforeUpdate() updated() onUpdated() beforeUnmount() onBeforeUnmount() unmounted() onUnmounted() 注意：在Composition API中没有beforeCreate()和created()这里两个声明周期函数了，统一使用setup()。 3.3.编程式路由的使用App.vue AboutView.vue "},{"title":"Router路由","date":"2022-07-20T11:28:58.000Z","url":"/2022/07/20/Router%E8%B7%AF%E7%94%B1/","tags":[["Vue3","/tags/Vue3/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"],["Vue3","/categories/%E5%89%8D%E7%AB%AF/Vue3/"]]},{"title":"MySQL索引","date":"2022-07-19T07:52:32.000Z","url":"/2022/07/19/MySQL%E7%B4%A2%E5%BC%95/","tags":[["MySQL","/tags/MySQL/"]],"categories":[["数据库","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"],["MySQL","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"]],"content":"​ ​ 索引是一种特殊的数据库结构，由数据表中的一列或多列组合而成，可以用来快速查询数据表中有某一特定值的记录。本节将详细讲解索引的含义、作用和优缺点。​ 通过索引，查询数据时不用读完记录的所有信息，而只是查询索引列。否则，数据库系统将读取每条记录的所有信息进行匹配。​ 可以把索引比作新华字典的音序表。例如，要查“库”字，如果不使用音序，就需要从字典的 400 页中逐页来找。但是，如果提取拼音出来，构成音序表，就只需要从 10 多页的音序表中直接查找。这样就可以大大节省时间。​ 因此，使用索引可以很大程度上提高数据库的查询速度，还有效的提高了数据库系统的性能。 为什么要使用索引​ 索引就是根据表中的一列或若干列按照一定顺序建立的列值与记录行之间的对应关系表，实质上是一张描述索引列的列值与原表中记录行之间一 一对应关系的有序表。 1) 顺序访问​ 顺序访问是在表中实行全表扫描，从头到尾逐行遍历，直到在无序的行数据中找到符合条件的目标数据。 2) 索引访问​ 索引访问是通过遍历索引来直接访问表中记录行的方式。 索引的优缺点索引有其明显的优势，也有其不可避免的缺点。 优点 索引的优点如下： 通过创建唯一索引可以保证数据库表中每一行数据的唯一性。 可以给所有的 MySQL 列类型设置索引。 可以大大加快数据的查询速度，这是使用索引最主要的原因。 在实现数据的参考完整性方面可以加速表与表之间的连接。 在使用分组和排序子句进行数据查询时也可以显著减少查询中分组和排序的时间 如： 使用非索引列花费时间： 使用索引查询花费时间大大减少： 缺点 增加索引也有许多不利的方面，主要如下： 创建和维护索引组要耗费时间，并且随着数据量的增加所耗费的时间也会增加。 索引需要占磁盘空间，除了数据表占数据空间以外，每一个索引还要占一定的物理空间。如果有大量的索引，索引文件可能比数据文件更快达到最大文件尺寸。 当对表中的数据进行增加、删除和修改的时候，索引也要动态维护，这样就降低了数据的维护速度。 使用索引时，需要综合考虑索引的优点和缺点。 ​ 索引可以提高查询速度，但是会影响插入记录的速度。因为，向有索引的表中插入记录时，数据库系统会按照索引进行排序，这样就降低了插入记录的速度，插入大量记录时的速度影响会更加明显。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后，再创建索引。 索引种类 分类 含义 特点 主键索引 对主键新建的索引 自动会新建索引,并且一个 唯一索引 对unique键新建的索引 可以N个,自动会新建索引 普通索引 普通类新建的索引 可以N个 全文检索 全文检索 可以有N个 案例分析 表结构 聚集索引 二级索引 语法创建索引（CREATE INDEX）​ 创建索引是指在某个表的一列或多列上建立一个索引，可以提高对表的访问速度。创建索引对 MySQL数据库的高效运行来说是很重要的。 create [ UNIQUE | FULLTEXT ] INDEX 索引名 ON 表名字 ( 列1,…列N ) ; explain含义分析执行计划 参数介绍 字段 含义 id 代表执行顺序值越大,越先执行,如果相同从上到下 select_type 查询类型,比如:primary(主查询),subquery(子查询),simple(简单查询) type 连接类型,性能由好到差的连接类型为NULL、system、const、 eq_ref、ref、range、 index、all 。 possible_key 显示可能用到的索引名 key 显示实际使用到的索引名 rows 必须要执行查询的行数只是一个估计值， filtered 返回结果的行数占需读取行数的百分比， filtered 的值越大越好。 执行成功： 索引使用建议失效情况 索引列运算 字符串必须添加单引号 数据分布影响 头部模糊查询 or 连接 少用select * 范围查询【使用在联合索引中】 最左前缀法则【使用在联合索引中】 原则 适当控制索引的数量 数据量较大 查询比较频繁 常作为查询条件（where）、排序（order by）、分组（group by）操作的字段 尽量建立唯一索引,使用索引的效率越高 字段的长度较长，可以针对于字段的特点，建立前缀索引 尽量使用联合索引，减少单列索引，查询时可以提高覆盖索引，节省存储空间， 避免回表。 "},{"title":"MySQL游标(Cursor)","date":"2022-07-19T07:32:31.000Z","url":"/2022/07/19/MySQL%E6%B8%B8%E6%A0%87-Cursor/","tags":[["MySQL","/tags/MySQL/"]],"categories":[["数据库","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"],["MySQL","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"]],"content":"​ 在 MySQL 中，存储过程或函数中的查询有时会返回多条记录，而使用简单的 SELECT 语句，没有办法得到第一行、下一行或前十行的数据，这时可以使用游标来逐条读取查询结果集中的记录。 ​ 一般通过游标定位到结果集的某一行进行数据修改。 结果集是符合 SQL 语句的所有记录的集合。个人理解游标就是一个标识，用来标识数据取到了什么地方，如果你了解编程语言，可以把他理解成数组中的下标。 语法 案例 "},{"title":"静态资源导出问题","date":"2022-07-18T15:39:38.000Z","url":"/2022/07/18/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%AF%BC%E5%87%BA%E9%97%AE%E9%A2%98/","tags":[["SSM","/tags/SSM/"]],"categories":[["SSM","/categories/SSM/"],["随笔","/categories/SSM/%E9%9A%8F%E7%AC%94/"]],"content":""},{"title":"SpringMV需要的依赖","date":"2022-07-18T15:34:52.000Z","url":"/2022/07/18/SpringMV%E9%9C%80%E8%A6%81%E7%9A%84%E4%BE%9D%E8%B5%96/","tags":[["Spring MVC","/tags/Spring-MVC/"]],"categories":[["Spring","/categories/Spring/"],["Spring MVC学习","/categories/Spring/Spring-MVC%E5%AD%A6%E4%B9%A0/"]],"content":" "},{"title":"自定义异常","date":"2022-07-18T15:28:50.000Z","url":"/2022/07/18/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8/","tags":[["java","/tags/java/"]],"categories":[["java","/categories/java/"],["随笔","/categories/java/%E9%9A%8F%E7%AC%94/"]],"content":"java自定义异常在java语言中允许用户自定义异常类。自定义异常类不是系统监测到的异常，而是由用户自己定义的异常。自定义异常同样需要try-catch-finally语句捕获，但**必须由用户自己抛出异常(throw new MyException)**用户自定义异常类时，只需要继承Exception类即可。 **步骤 **: 创建自定义异常类在方法中通过throw关键字抛出异常对象。如果在当前抛出异常的方法中处理异常，可以使用try-catch语句捕获异常并处理；否则在方法的声明处通过throws关键字指明要抛出给方法调用者的异常，继续进行下一步操作。在出现异常方法的调用者中捕获并处理异常。 ​ Throwable下面的列表显示了Throwable类的一些常用方法。 ​ Throwable类是Java中所有异常类的超类 有两种子类：Error和Exception。此表中显示的所有方法在所有异常类中都可用。 ​ Throwable getCause()返回异常的原因。如果未设置异常的原因，则返回null。 ​ String getMessage()返回异常的详细消息。 ​ StackTraceElement[] getStackTrace()返回堆栈跟踪元素的数组。 ​ Throwable initCause(Throwable cause)设置异常的原因。有两种方法可以将异常设置为异常的原因。其他方法是使用构造函数，它接受原因作为参数。 ​ void printStackTrace()在标准错误流上打印堆栈跟踪。 ​ void printStackTrace(PrintStream s)将堆栈跟踪打印到指定的PrintStream对象。 ​ void printStackTrace(PrintWriter s)将堆栈跟踪打印到指定的PrintWriter对象。 ​ String toString()返回异常对象的简短描述。 throws和throw的区别(面试题)​ throws用在方法声明后面，跟的是异常类名可以跟多个异常类名，用逗号隔开表示抛出异常，由该方法的调用者来处理throws表示出现异常的一种可能性，并不一定会发生这些异常throw用在方法体内，跟的是异常对象名只能抛出一个异常对象名表示抛出异常，由方法体内的语句处理throw则是抛出了异常，执行throw则一定抛出了某种异常"},{"title":"各种Date之间的转换方法","date":"2022-07-18T15:23:01.000Z","url":"/2022/07/18/%E5%90%84%E7%A7%8DDate%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/","tags":[["java","/tags/java/"]],"categories":[["java","/categories/java/"],["随笔","/categories/java/%E9%9A%8F%E7%AC%94/"]],"content":"一、java Date时间的各种转换方式 二、MySQL数据库中的Date,DateTime,TimeStamp和Time类型​ DATETIME类型用在你需要同时包含日期和时间信息的值时。MySQL检索并且以’YYYY-MM-DD HH:MM:SS’格式显示DATETIME值，支持的范围是’1000-01-01 00:00:00’到’9999-12-31 23:59:59’。（“支持”意味着尽管更早的值可能工作，但不能保证他们可以。） ​ DATE类型用在你仅需要日期值时，没有时间部分。MySQL检索并且以’YYYY-MM-DD’格式显示DATE值，支持的范围是’1000-01-01’到’9999-12-31’。 TIMESTAMP列类型提供一种类型，你可以使用它自动地用当前的日期和时间标记INSERT或UPDATE的操作。 ​ TIME数据类型表示一天中的时间。MySQL检索并且以”HH:MM:SS”格式显示TIME值。支持的范围是’00:00:00’到’23:59:59’。 三：mysql中存入timestamp 类型时间需要java将时间转为其数据库对应的数据格式 四、datetime和timestamp的区别：1.datetime 的日期范围比较大；如果有1970年以前的数据还是要用datetime.但是timestamp 所占存储空间比较小。 2.timestamp 类型的列还有个特性：默认情况下，在 insert, update 数据时，timestamp 列会自动以当前时间（CURRENT_TIMESTAMP）填充&#x2F;更新。3.timestamp比较受时区timezone的影响以及MYSQL版本和服务器的SQL MODE的影响.使用一个常用的格式集的任何一个，你可以指定DATETIME、DATE和TIMESTAMP值：’YYYY-MM-DD HH:MM:SS’或’YY-MM-DD HH:MM:SS’格式的一个字符串,允许一种”宽松”的语法:任何标点可用作在日期部分和时间部分之间的分隔符。例如，’98-12-31 11:30:45’、’98.12.31 11+30+45’、’98&#x2F;12&#x2F;31 113045’和‘98@12@31 11^30^45’是等价的。"},{"title":"组件传值、ES6学习","date":"2022-07-18T15:14:53.000Z","url":"/2022/07/18/%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC%E3%80%81ES6%E5%AD%A6%E4%B9%A0/","tags":[["Vue3","/tags/Vue3/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"],["Vue3","/categories/%E5%89%8D%E7%AB%AF/Vue3/"]],"content":"组件含义封装一段html代码,避免重复开发 特点 也是一个实例,也有data、methods等等属性 template属性代表组件内容【html代码】 不用挂载到某个标签中 避免重复开发 分类 全局组件 语法 局部组件 语法 全局组件VS局部组件 全局组件:到处可以使用【全局组件是在vue实例中注册】 局部组件:谁注册了局部组件,谁才可以使用。 案例全局案例 局部组件 全局组件独立性验证 局部组件独立性验证 组件通讯通常一个单页应用会以一棵嵌套的组件树的形式来组织 父向子简单参数 复杂参数 子向父 ES6扩展知识let含义和var一样用来声明变量的 和var的区别 var的作用域只有全局和局部,let除了又全局和局部作用域还有块级作用域 var存在变量提升,而let没有 var没有暂时性死区而let存在暂时性死区 案例分析自行分析结果是什么?以及为什么? constes6中的用来声明常量的 模板字符串含义 使用反引号将字符串括起来 里面使用${对象.属性}方式获取指定对象的属性值 好处比传统方式字符串拼接更加方便 rest参数含义 和java的可变参数一样 本质就是一个数组 语法 注意点 一个函数最多只能有一个rest参数 rest参数只能做为最后一个参数 案例 箭头函数含义一种简写的函数方式 王道做法 将以前函数的function去掉 在形式参数和函数体的中间添加&#x3D;&gt;即可 箭头函数注意点 this代表上下文 箭头函数中不可以使用arguments对象,如果要使用可以用rest参数代替 箭头不可以作为构造函数,否则会报错 案例一 案例二主要讲解注意点 Class含义类,用来创建对象的，是对象的模板 constructor含义构造器\\构造函数\\构造方法 特点 默认有一个无参构造器 默认返回this 可以手动return this 也可以手动return 其他对象 原型含义 每一个类都有一个唯一的原型 该类创建的对象共享类的原型。 该类创建的对象,可以继承到原型的属性或方法 获取 类名.prototype 对象名.__proto__ 静态语法 类名.属性&#x3D;属性值; 类名.属性 类名.方法&#x3D;方法; 类名.方法 案例 传统开发模式的主要问题 命名冲突 多个js文件中如果存在相同的变量名的时候,后者会覆盖前者 文件依赖 开发人员必须要很清楚js之间的依赖关系,并指定其加载顺序 项目庞大之后维护、扩展、管理很麻烦 模块化含义把特定功能封装到一个模块中(其实就是一个单独的js文件),可以暴露需要暴露的信息。 特点 模块与模块之间相互隔离 模块可以引用其他模块 常见模块化规范前端 AMD CMD 后端 CommonJS ES6模块化含义在ES6模块化规范诞生之前, JavaScript社区已经尝试并提出了AMD, CMD,CommonJS等模块化规范但是, 这些规范还存在一定的差异性与局限性, 并不是浏览器与服务端通用的模块化标准; 因此,ES6语法规范,在语言层面生定义了ES6模块化规范, 是浏览器与服务端通用的模块化开发规范; 规范 一个js文件就是一个模块 通过export暴露模块中信息 通过import导入模块中的信息 import含义导入 注意点 import命令具有提升效果，会提升到整个模块的头部，首先执行 import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构 如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次 拆解导入 案例一one.js index.js 02模块化.html 案例二a.js b.js otherIndex.js 03模块化 案例三myDefault.js defaultIndex.js 04模块化.html "},{"title":"springboot2面试宝典","date":"2022-07-18T12:29:23.000Z","url":"/2022/07/18/springboot2%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/","tags":[["springboot2","/tags/springboot2/"]],"categories":[["springboot2","/categories/springboot2/"],["面试宝典","/categories/springboot2/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"]],"content":"1. 说说Spring Boot常用的注解解题思路 得分点 Spring Boot常用注解的作用 标准回答 关于Spring Boot常用注解： @SpringBootApplication注解： 在Spring Boot入口类中,唯一的一个注解就是@SpringBootApplication。它是Spring Boot项目的核心注解,用于开启自动配置,准确说是通过该注解内组合的@EnableAutoConfiguration开启了自动配置。 @EnableAutoConfiguration注解： @EnableAutoConfiguration的主要功能是启动Spring应用程序上下文时进行自动配置,它会尝试猜测并配置项目可能需要的Bean。自动配置通常是基于项目classpath中引入的类和已定义的Bean来实现的。在此过程中,被自动配置的组件来自项目自身和项目依赖的jar包中。 @Import注解： @EnableAutoConfiguration的关键功能是通过@Import注解导入的ImportSelector来完成的。从源代码得知@Import(AutoConfigurationImportSelector.class)是@EnableAutoConfiguration注解的组成部分,也是自动配置功能的核心实现者。 @Conditional注解： @Conditional注解是由Spring 4.0版本引入的新特性,可根据是否满足指定的条件来决定是否进行Bean的实例化及装配,比如,设定当类路径下包含某个jar包的时候才会对注解的类进行实例化操作。总之,就是根据一些特定条件来控制Bean实例化的行为。"},{"title":"MySQL-02","date":"2022-07-18T11:34:14.000Z","url":"/2022/07/18/MySQL-02/","tags":[["MySQL","/tags/MySQL/"]],"categories":[["数据库","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"],["MySQL","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"]],"content":"数据类型示意图 数值型 类型 空间大小[字节] 范围（有符号） 范围（无符号） 用途 TINYINT 1 (-128，127) (0，255) 小整数值 SMALLINT 2 (-32 768，32 767) (0，65 535) 大整数值 MEDIUMINT 3 (-8 388 608，8 388 607) (0，16 777 215) 大整数值 INT或INTEGER 4 (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 BIGINT 8 极大整数值 FLOAT 4 单精度 浮点数值 DOUBLE 8 双精度 浮点数值 DECIMAL 如果M&gt;D，为M+2否则为D+2 依赖于M和D的值 依赖于M和D的值 小数值 字符串 类型 空间大小[字节] 备注 char 0-255 定长字符串(需要指定长度) varchar 0-65535 变长字符串(需要指定长度) tinytext 0-255 短文本字符串 text 0-65535 长文本数 mediumtext 0-16777215 中等长度文本数据 longtext 0-4294967295 极大文本数据 tinyblob 0-255 不超过255个字符的二进制数据 blob 0-65535 二进制形式的长文本数据 mediumblob 0-16777215 二进制形式的中等长度文本数据 longblob 0-4294967295 二进制形式的极大文本数据 日期类型 类型 空间大小[字节] 备注 time 3 时分秒 date 3 年月日 datetime 8 年月日时分秒 timestamp 4 时间戳类型，TIMESTAMP列用于INSERT或UPDATE操作时记录日期和时间 year 1 不推荐使用 其他 类型 备注 enum 枚举类型 set 集合类型 案例 约束 案例 SQL含义结构化查询语言(Structured Query Language)简称SQL, 是操作和检索关系型数据库的标准语言 分类 DQL DML DCL DDL TPL 书写规则 不区分大小写，也就是说SELECT，select，Select，执行时效果是一样的。 可以单行来书写，也可以书写多行,通过Tab和缩进的使用可以提高程序的可读性。 关键字不可以缩写、分开以及跨行书写，如SELECT不可以写成SEL或SELE CT等形式。 关键字最好使用大写，其它语法元素（如列名、表名等）小写。 准备数据 DQL含义数据查询语言 语法 案例 算术运算可以在SELECT语句中使用算术运算符，改变输出结果 优先级 乘除优先于加减 相同优先权的表达式按照从左至右的顺序依次计算 括弧可以提高优先权，并使表达式的描述更为清晰 案例 NULL空值是指一种无效的、未赋值、未知的或不可用的值。空值不同于零或者空格 注意点 任何包含空值的算术表达式运算后的结果都为空值NULL ifnull(列名,代替值)函数来处理空值 案例 列别名用来重新命名列的显示标题,如果SELECT语句中包含计算列，通常使用列别名来重新定义列标题。 语法 列名 列别名 列名 AS 列别名 DISTINCT在SELECT字句中使用关键字DISTINCT可消除重复行 案例 WHERE 字句语法 通常格式为：列名 比较操作符 要比较的值 案例 特殊比较符 案例 逻辑运算符 AND OR NOT NOT IN NOT BETWEEN 开始 AND 结束 NOT LIKE IS NOT NULL 优先级 默认优先级 NOT &gt; AND &gt; OR 改变优先级 适当添加()可以改变优先级同时也可以提高代码可读性 案例一 案例二 order by排序 规则 即按照数字大小顺序由小到大排列。 日期升序排列相对较早的日期在前，较晚的日期在后。 字符升序排列按照字母由小到大的顺序排列。即由A-Z排列,中文升序按照字典顺序排列。 空值在升序排列中排在最前面，在降序排列中排在最后。 语法 可以按照列名、表达式、列别名、结果集的列序号排序 ORDER BY 子句必须写在SELECT语句的最后 ASC 为升序,DESC为降序 案例 limit分页 语法 案例 函数mySQL提供了很多功能强大、方便易用的函数，在进行数据库管理以及数据的查询和操作时，帮助我们提高对数据库的管理效率。 分类 单行函数语法函数名[(参数1，参数2,…)] 其中的参数可以是以下之一： 变量 列名 表达式 特点 单行函数对单行操作 每行返回一个结果 有可能返回值与原参数数据类型不一致 单行函数可以写在SELECT、WHERE、ORDER BY子句中 有些函数没有参数，有些函数包括一个或多个参数 函数可以嵌套 数学函数常见 abs() 求绝对值 pi() 返回pi sqrt(x) 开平方根 mod(x) 求余数 ceil(x)\\ceiling(x) 向上取整 floor(x) 向下取整 round() 四舍五入取整 round(x,y) 四舍五入保留小数点y位取整 truncate(x,y) 截断 rand() 返回随机数？ sign(x) 返回符号为,整数返回1负数返回-1,0就返回0 pow(x,y)\\power(x,y) 返回x数据求y次方后的结果 案例 字符串函数常见 char_length(x) 求字符的个数 length(x) 返回字节个数 concat(str1,str2,…) 字符串拼接,如果有一个参数是null那么全部返回都是null concat_ws(sepe0rator,str1,str2,…) 字符串拼接,拼接的分隔符使用seperator,如果被拼接的参数是null,则会忽略 insert(str,position,len,newStr) 在str的指定位置开始取len个字符并用newStr来代替 lower(x) 转成小写 upper(x) 转成大写 left(str,len) 返回字符串str的左边开始计算共返回len个字符 right(str,len) 返回字符串str的右边开始计算共返回len个字符 lpad(str,len,newStr) 对str的左边开始用newStr填充直到填充后的字符串长度为len为止 rpad(str,len,newStr) 对str的右边开始用newStr填充直到填充后的字符串长度为len为止 ltrim(x) 去除字符串x的左边空格 rtrim(x) 去除字符串x的右边空格 trim(x) 去除字符串x左右两边的隔空 trim( delStr from str) 去除字符串str中左右两边的delStr字符串 repeat(str,times) 返回一个新字符串,该字符串由于字符串str重复times次组成 space(n) 返回n个由于空格组成的字符串 replace(str,source,target) 返回str字符串中source子串被target字符串替换的结果 strcmp(x,y) 返回字符串x和y的比较结果,如果是相等返回0,x大于y返回1,否则返回-1 substring(str,startPosition[,len]) 如果len没有写,返回的是字符串str中从startPosition开始截取到末尾字符串 如果len有指定,返回的是字符串str中从stratPosition开始截取len个字符串 reverse(x) 对字符串x逆序(倒序) ELT(position,str1,str2,…) 返回的是参数中str1,str2,…参数中第position个位置的字符串 案例"},{"title":"MySQL-04","date":"2022-07-18T11:32:12.000Z","url":"/2022/07/18/day04/","tags":[["MySQL","/tags/MySQL/"]],"categories":[["数据库","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"],["MySQL","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"]],"content":"ANY含义任意,也可以理解为只要满足一个就好了。 语法&#x3D; ANY 相当于in &lt;ANY 相当于小于最大值 &gt;ANY 相当于大于最小值 案例 ALL含义满足全部 语法&#x3D; ALL 等于全部,没有任何意义 &lt; ALL 小于最小值 &gt;ALL 大于最大值 案例 not in注意点只要空值有可能成为子查询结果集合中的一部分，就不能使用NOT IN 运算符 方案子查询中将null值排除掉 案例 表之间的关系种类 one to many 【many to one】 dept和emp customer和book user和car many to many stu和teacher user和role one to one qq和zone user和card 案例oneToMany manyToMany oneToOne 嵌套子查询位置 from where having 作用 条件 where having 表 from 执行过程 子查询首先执行一次 给主查询作为查询参数 作为一张临时表 相关子查询含义当子查询中引用了父查询表中的一个列时,此时数据库服务器就执行相关子查询。 特点 主查询有N条记录,子查询就要执行N次 执行过程 入门案例 示意图1 示意图2 其他案例 使用位置 select where 如何判断根据子查询是否使用主查询的参数来判断 课堂练习 查询所有雇员编号、名字、部门名字 查询哪些员工是经理 查询哪些员工不是经理 查询每个部门工资最低的两个员工编号、姓名、工资 视图含义 是sql语句的封装 本身不保存数据 数据来自基础表或者其他视图 示意图 为什么要用 避免重复编写sql语句 封装复杂的sql语句 显示部分列数据 语法创建或修改 删除 查看 使用 选项 cascaded 这是默认的,代表检查选项会级联传递 local 代表选项不会级联传递 案例一 案例二 案例三 案例四 权限含义对于资源只有有权限的用户才能操作 相关表 user db tables_priv columns_priv procs_priv 执行示意图 用户管理语法创建用户 修改名字 修改密码 删除用户 案例 权限管理语法 案例 核实步骤 事务含义对数据库的一组操作要不同时成功,要不同时失败。 特性 特性 含义 原子性 不可分割的最小单位 一致性 事务结束后数据保持不变 隔离性 事务之间互不影响【隔离级别有关系】 持久性 事务结束之后断电重启后事务不会回滚 组成 DML+TPL DML+DDL DML+DCL 手动结束案例一 案例二 自动结束自行验证,了解即可 自动提交 执行一个DDL(CREATE、ALTER、DROP、TRUNCATE、RENAME）语句； 执行一个DCL(GRANT、REVOKE)语句； 自动回滚 客户端强行退出 客户端连接到服务器端异常中断 系统崩溃 还原点 事物隔离级别 READ UNCOMMITTED READ COMMITTED REPEATABLE READ【默认】 SERIALIZABLE 脏读 y n n n 不可重复读 y y n n 幻读(虚读) y y y n 解释脏读: 一个事务读取到另一个事务未提交的数据 不可重复读:一个相同的事务多次读取的数据不一样 幻读:强调在于某一个范围内的数据行变多或者是变少了，侧重说明的是数据集不一样导致了产生了幻读。 查看 修改 SESSION 代表只会对当前会话有效 GLOBAL 代表会对所有会话有效 "},{"title":"MySQL-03","date":"2022-07-18T11:31:15.000Z","url":"/2022/07/18/day03/","tags":[["MySQL","/tags/MySQL/"]],"categories":[["数据库","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"],["MySQL","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"]],"content":"日期函数常见 curdate() current_date() 获取当前年月日 curtime() current_time() 获取当前时分秒 now() sysdate() 获取当前年月日时分秒 datediff(date1,date2) 返回date1-date2相差的天数 date_add(time,interval exp unit) select date_add(now(),interval 1 DAY) from dual; 给指定时间time加上单位为unit的exp date_sub(time,interval exp unit) 给指定时间time减去单位为unit的exp 常见unit如下: time_format(time,format) 将时间time的时分秒【只对时分秒】信息按照format指定的格式格式化为字符串并返回 date_format(time,format) 将时间time按照format指定的格式格式化为字符串并返回 常见格式如下: 案例 其他函数 database() 获取当前使用的数据库实例名 version() 获取数据的版本 user() 获取当前登录用户 md5(明文) 获取明文MD5后的摘要信息 password(明文) 获取明文加密后的密文,mysql使用该函数加密用户的密码**(注意了mysql 8 版本是没有该函数的)** 案例 控制语句常见 case 语法 if(expression,成立,不成立) 类似于三目运算符 ifnull(expression,成立) 判断expression是否为空,如果为空则返回成立结果 nullif 案例 多表查询含义显示的数据不仅仅来自一张表中,可能是来自两张甚至更多。 分类 连接条件分 等值连接 非等值连接 按其他连接方法分 外连接 内连接 笛卡尔积含义显示的记录数量是各个查询表中记录数的乘积 产生原因多表连接查询中缺少有效的关联的条件 处理方案多表连接查询中添加有效的关联的条件,如果M张表查询至少需要M-1个有效的关联条件 案例 等值连接含义有效关联添加是等值比较的 案例 非等值连接含义有效关联添加不是使用等值比较的 案例一 自身连接相同表之间做关联查询 案例 ANSI标准 连接语句所有关系型数据都要支持的语法 交叉连接 【了解】 自然连接 【了解】 using连接 【了解】 inner join .. on 子句 left join .. on 子句 right join .. on 子句 inner join内连接 语法 好处 将有效关联条件和其他条件分开 提高可读性 案例 left join左外连接(不管左边有没有和右边匹配都要显示) 语法 案例 right join右外连接(不管右边有没有和左边匹配都要显示) 语法 案例 分组函数分数函数也叫多行参数,是将多行作为参数 常见 min MIN([DISTINCT|ALL] column|expression) max MAX([DISTINCT|ALL] column|expression) avg AVG([DISTINCT|ALL] column|expression) sum SUM([DISTINCT|ALL] column|expression) count COUNT ( * | { [DISTINCT|ALL] column}) 语法 分组函数位置: select having order by 注意点 除了count(*)之外,其他的分组函数都会忽略null值 案例 思考请问如下结构多少? 请问是否报错? group by 语句含义按照指定条件将数据分组 示意图 语法 注意点使用了group by 之后,select 后面不可以写可以写分组函数、分组的依据列 案例 having含义对分组后进一步的过滤 示意图 语法 案例 执行顺序 from where group by select字段 having order by limit 子查询含义查询语句中的查询语句,也称从查询、内部查询 示意图 规范 用(子查询)包裹起来 放到比较运算符的右边 使用适当的比较运算符 单行运算符：&gt;、&#x3D;、&gt;&#x3D;、&lt;、&lt;&gt;、&lt;&#x3D; 多行运算符： IN、ANY、ALL 使用地方 where from having 案例一在where中使用子查询 案例二在from和having使用子查询 案例三在from中使用子查询 "},{"title":"MySQL事务面试宝典","date":"2022-07-18T10:56:19.000Z","url":"/2022/07/18/MySQL%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/","tags":[["MySQL","/tags/MySQL/"]],"categories":[["数据库","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"],["MySQL","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"]],"content":"​ 事务处理语言：Transaction Process Language ,简称TPL，主要用来对组成事务的DML语句的操作结果进行确认或取消。确认也就是使DML操作生效，使用提交(COMMIT)命令实现；取消也就是使DML操作失效，使用回滚(ROLLBACK)命令实现。 ​ 通过事务的使用，能防止数据库中出现数据不一致现象。如两个银行账户进行转账，涉及到两条更新操作，这两条更新操作只允许全部成功或失败，否则数据会出现不一致的现象。 1.1 对数据库事务的了解​ 事务：对数据库的一组操作，要么都执行修改，要么都不执行，这就是事务的目的。 事务需遵循ACID四个特性： A（atomicity），原子性。原子性指整个数据库事务是不可分割的工作单位。只有使事务中所有的数据库操作都执行成功，整个事务的执行才算成功。事务中任何一个SQL语句执行失败，那么已经执行成功的SQL语句也必须撤销，数据库状态应该退回到执行事务前的状态。 C（consistency），一致性。一致性指事务将数据库从一种状态转变为另一种一致的状态。在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。 I（isolation），隔离性。事务的隔离性要求每个读写事务的对象与其他事务的操作对象能相互分离，即该事务提交前对其他事务都不可见，这通常使用锁来实现。 D（durability） ，持久性。事务一旦提交，其结果就是永久性的，即使发生宕机等故障，数据库也能将数据恢复。持久性保证的是事务系统的高可靠性，而不是高可用性。 1.2 MySQL的ACID特性分别是怎么实现的？原子性实现原理： ​ 实现原子性的关键，是当事务回滚时能够撤销所有已经成功执行的sql语句。InnoDB实现回滚靠的是undo log，当事务对数据库进行修改时，InnoDB会生成对应的undo log。如果事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。 undo log属于逻辑日志，它记录的是sql执行相关的信息。当发生回滚时，InnoDB会根据undo log的内容做与之前相反的工作。对于insert，回滚时会执行delete。对于delete，回滚时会执行insert。对于update，回滚时则会执行相反的update，把数据改回去。 持久性实现原理： ​ InnoDB作为MySQL的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低。为此，InnoDB提供了缓存(Buffer Pool)，Buffer Pool中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲。当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool。当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中（这一过程称为刷脏）。 ​ Buffer Pool的使用大大提高了读写数据的效率，但是也带了新的问题：如果MySQL宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。 ​ 于是，redo log被引入来解决这个问题。当数据修改时，除了修改Buffer Pool中的数据，还会在redo log记录这次操作。当事务提交时，会调用fsync接口对redo log进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。redo log采用的是WAL（Write-ahead logging，预写式日志），所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求。 既然redo log也需要在事务提交时将日志写入磁盘，为什么它比直接将Buffer Pool中修改的数据写入磁盘(即刷脏)要快呢？主要有以下两方面的原因： 刷脏是随机IO，因为每次修改的数据位置随机，但写redo log是追加操作，属于顺序IO。 刷脏是以数据页（Page）为单位的，MySQL默认页大小是16KB，一个Page上一个小修改都要整页写入。而redo log中只包含真正需要写入的部分，无效IO大大减少。 隔离性实现原理： ​ 隔离性追求的是并发情形下事务之间互不干扰。简单起见，我们主要考虑最简单的读操作和写操作(加锁读等特殊读操作会特殊说明)，那么隔离性的探讨，主要可以分为两个方面。 第一方面，(一个事务)写操作对(另一个事务)写操作的影响：锁机制保证隔离性。 ​ 隔离性要求同一时刻只能有一个事务对数据进行写操作，InnoDB通过锁机制来保证这一点。锁机制的基本原理可以概括为：事务在修改数据之前，需要先获得相应的锁。获得锁之后，事务便可以修改数据。该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。 ​ 按照粒度，锁可以分为表锁、行锁以及其他位于二者之间的锁。表锁在操作数据时会锁定整张表，并发性能较差。行锁则只锁定需要操作的数据，并发性能好。但是由于加锁本身需要消耗资源，因此在锁定数据较多情况下使用表锁可以节省大量资源。MySQL中不同的存储引擎支持的锁是不一样的，例如MyIsam只支持表锁，而InnoDB同时支持表锁和行锁，且出于性能考虑，绝大多数情况下使用的都是行锁。 ​ 第二方面，(一个事务)写操作对(另一个事务)读操作的影响：MVCC保证隔离性。 ​ InnoDB默认的隔离级别是RR（REPEATABLE READ），RR解决脏读、不可重复读、幻读等问题，使用的是MVCC。MVCC全称Multi-Version Concurrency Control，即多版本的并发控制协议。它最大的优点是读不加锁，因此读写不冲突，并发性能好。InnoDB实现MVCC，多个版本的数据可以共存，主要基于以下技术及数据结构： 隐藏列：InnoDB中每行数据都有隐藏列，隐藏列中包含了本行数据的事务id、指向undo log的指针等。 基于undo log的版本链：每行数据的隐藏列中包含了指向undo log的指针，而每条undo log也会指向更早版本的undo log，从而形成一条版本链。 ReadView：通过隐藏列和版本链，MySQL可以将数据恢复到指定版本。但是具体要恢复到哪个版本，则需要根据ReadView来确定。所谓ReadView，是指事务（记做事务A）在某一时刻给整个事务系统（trx_sys）打快照，之后再进行读操作时，会将读取到的数据中的事务id与trx_sys快照比较，从而判断数据对该ReadView是否可见，即对事务A是否可见。 一致性实现原理： ​ 可以说，一致性是事务追求的最终目标。前面提到的原子性、持久性和隔离性，都是为了保证数据库状态的一致性。此外，除了数据库层面的保障，一致性的实现也需要应用层面进行保障。实现一致性的措施包括： 保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证。 数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等。 应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致。 1.3 谈谈MySQL的事务隔离级别参考答案 SQL 标准定义了四种隔离级别，这四种隔离级别分别是： 读未提交（READ UNCOMMITTED）； 读提交 （READ COMMITTED）； 可重复读 （REPEATABLE READ）； 串行化 （SERIALIZABLE）。 事务隔离是为了解决脏读、不可重复读、幻读问题，下表展示了 4 种隔离级别对这三个问题的解决程度： 隔离级别 脏读 不可重复读 幻读 READ UNCOMMITTED 可能 可能 可能 READ COMMITTED 不可能 可能 可能 REPEATABLE READ 不可能 不可能 可能 SERIALIZABLE 不可能 不可能 不可能 ​ 上述4种隔离级别MySQL都支持，并且InnoDB存储引擎默认的支持隔离级别是REPEATABLE READ，但是与标准SQL不同的是，InnoDB存储引擎在REPEATABLE READ事务隔离级别下，使用Next-Key Lock的锁算法，因此避免了幻读的产生。所以，InnoDB存储引擎在默认的事务隔离级别下已经能完全保证事务的隔离性要求，即达到SQL标准的SERIALIZABLE隔离级别。 扩展阅读 并发情况下，读操作可能存在的三类问题： 脏读：当前事务(A)中可以读到其他事务(B)未提交的数据（脏数据），这种现象是脏读。 不可重复读：在事务A中先后两次读取同一个数据，两次读取的结果不一样，这种现象称为不可重复读。脏读与不可重复读的区别在于：前者读到的是其他事务未提交的数据，后者读到的是其他事务已提交的数据。 幻读：在事务A中按照某个条件先后两次查询数据库，两次查询结果的条数不同，这种现象称为幻读。不可重复读与幻读的区别可以通俗的理解为：前者是数据变了，后者是数据的行数变了。 1.4 MySQL的事务隔离级别是怎么实现的？InnoDB支持四种隔离级别，每种级别解决掉的问题如下表： 脏读 不可重复读幻读 幻读 READ UNCOMMITTED Y Y Y READ COMMITTED N Y Y REPEATABLE READ（默认） N N N SERIALIZABLE N N N 这四种隔离级别的实现机制如下： READ UNCOMMITTED &amp; READ COMMITTED： 通过Record Lock算法实现了行锁，但READ UNCOMMITTED允许读取未提交数据，所以存在脏读问题。而READ COMMITTED允许读取提交数据，所以不存在脏读问题，但存在不可重复读问题。 REPEATABLE READ： 使用Next-Key Lock算法实现了行锁，并且不允许读取已提交的数据，所以解决了不可重复读的问题。另外，该算法包含了间隙锁，会锁定一个范围，因此也解决了幻读的问题。 SERIALIZABLE： 对每个SELECT语句后自动加上LOCK IN SHARE MODE，即为每个读取操作加一个共享锁。因此在这个事务隔离级别下，读占用了锁，对一致性的非锁定读不再予以支持。 1.5 事务可以嵌套吗？参考答案 可以，因为嵌套事务也是众多事务分类中的一种，它是一个层次结构框架。有一个顶层事务控制着各个层次的事务，顶层事务之下嵌套的事务被称为子事务，它控制每一个局部的变换。 需要注意的是，MySQL数据库不支持嵌套事务。 1.6 如何实现可重复读？参考答案 MySQL的InnoDB引擎，在默认的REPEATABLE READ的隔离级别下，实现了可重复读，同时也解决了幻读问题。它使用Next-Key Lock算法实现了行锁，并且不允许读取已提交的数据，所以解决了不可重复读的问题。另外，该算法包含了间隙锁，会锁定一个范围，因此也解决了幻读的问题。 1.7 如何解决幻读问题？参考答案 MySQL的InnoDB引擎，在默认的REPEATABLE READ的隔离级别下，实现了可重复读，同时也解决了幻读问题。它使用Next-Key Lock算法实现了行锁，并且不允许读取已提交的数据，所以解决了不可重复读的问题。另外，该算法包含了间隙锁，会锁定一个范围，因此也解决了幻读的问题。 1.8 MySQL事务如何回滚？参考答案 在MySQL默认的配置下，事务都是自动提交和回滚的。当显示地开启一个事务时，可以使用ROLLBACK语句进行回滚。该语句有两种用法： ROLLBACK：要使用这个语句的最简形式，只需发出ROLLBACK。同样地，也可以写为ROLLBACK WORK，但是二者几乎是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。 ROLLBACK TO [SAVEPOINT] identifier ：这个语句与SAVEPOINT命令一起使用。可以把事务回滚到标记点，而不回滚在此标记点之前的任何工作。 1.9 请你说说MySQL的事务隔离级别1：读未提交（read uncommited）：一个事务可以读取到其他事务修改了但是还没有提交的数据，所以在该隔离级别下是不加任何共享锁或者排他锁的，相应的它的执行速度最快，但是会导致脏读，不可重复读和幻读的情况发生。 2，串型化（seriazeable）：当一个事务读取某个数据时，他会对整张表加共享锁，修改时，整张表加排他的，所以它的性能时最低的，但是脏读，幻读，不可重复读的问题不会出现。 3，读已提交（readcommitted）：指一个事务只能读到其他事务修改提交后的数据，若数据只是修改了还未提交，那么此时读取的数据便不是当前读而是有MVCC中readview提供的数据快照（老版本数据），可以避免脏读，不可避免不可重复读和幻读。 4，可重复读（repeatable）：是指一个事务连续两次读取到的数据都是相同的，无论这两次读取的过程中是否有其他事修改了该数据。他避免了脏读，不可重复读。不能避免幻读，同时它也是mysql默认的隔离级别。在MVCC中每一个事务都会有一个readview，在readcommited隔离级别中：一个事务每快照读一次都会重新生成一次readview。所以他无法避免不可重复度，而repeatable中，仅在事务开启时生成一次readview，后续的读取操作都会复用这个readview所以每次读取同一个数据时读取的值都是一样的，这就是它实现避免不可重复读的原理。 ​ 事务隔离级别是为了解决脏读，不可重复读，幻读。MySQL的事务隔离级别有四种，分别是读未提交，读已提交，可重复读，可串行化。读未提交不能解决脏读，幻读和不可重复读。读已提交解决了脏读的问题，可重复读解决了脏读和不可重复读，但是幻读依然存在。可串行化解决了脏读，幻读，不可重复读，MySQL默认使用可重复读"},{"title":"Props类型传值","date":"2022-07-16T07:31:40.000Z","url":"/2022/07/16/Props%E7%B1%BB%E5%9E%8B%E4%BC%A0%E5%80%BC/","tags":[["Vue3","/tags/Vue3/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"],["Vue3","/categories/%E5%89%8D%E7%AB%AF/Vue3/"]],"content":"一、单向数据流​ 所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。 ​ 另外，每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。 ​ 当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名： 二、父向子2.1 简单参数 2.2 复杂参数 注： &lt;inner :users=&quot;users&quot; :num=&quot;100&quot;&gt;&lt;/inner&gt; 中，:users是组件中定义的属性，第二个users是父组件定义的值 props 中的s是多个的意思。 &lt;inner :users=&quot;users&quot; :num=&quot;100&quot;&gt;&lt;/inner&gt; 可对props属性进行限制，如果num没有绑定事件，就是一个字符串数据。 "},{"title":"分组函数（高级查询）","date":"2022-07-15T16:37:53.000Z","url":"/2022/07/16/%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2%EF%BC%88%E9%AB%98%E7%BA%A7%E6%9F%A5%E8%AF%A2%EF%BC%89/","tags":[["MySQL","/tags/MySQL/"]],"categories":[["数据库","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"],["MySQL","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"]],"content":"分组函数概述​ 分组函数是对表中一组记录进行操作，每组只返回一个结果，即首先要对表记录进行分组，然后再进行操作汇总，每组返回一个结果，分组时可能是整个表分为一组，也可能根据条件分成多组。 分组函数常用到以下五个函数： MIN MAX SUM AVG COUNT 使用分组函数 分组函数练习1.查询部门20的员工，每个月的工资总和及平均工资。 2.查询工作在CHICAGO的员工人数，最高工资及最低工资。 3.查询员工表中一共有几种岗位类型。 GROUP BY分组练习1.查询每个部门的部门号，部门名称，部门人数，最高工资，最低工资，工资总和，平均工资 2、查询每个部门，每个岗位的部门编号，部门名称，岗位名称，部门人数，最高工资，最低工资，工资总和，平均工资 3、查询每个经理所管理的人数，经理编号，经理姓名，要求包括没有经理的人员信息 用 HAVING 子句排除组结果使用 HAVING 子句限制组 记录已经分组. 使用过组函数. 与 HAVING 子句匹配的结果才输出 不能在 WHERE子句中限制组可以通过 HAVING 子句限制组 SELECT语句执行过程 通过FROM子句中找到需要查询的表； 通过WHERE子句进行非分组函数筛选判断； 通过GROUP BY子句完成分组操作; 通过HAVING子句完成组函数筛选判断； 通过SELECT子句选择显示的列或表达式及组函数； 通过ORDER BY子句进行排序操作。 1.查询部门人数大于2的部门编号，部门名称，部门人数。 2.查询部门平均工资大于2000，并且人数大于2的部门编号– 部门名称，部门人数，部门平均工资，并按照部门人数升序排列 3.查出比JONES工资高的其它员工 单行子查询子查询只返回一行一列使用单行运算符（&gt;、&lt;、&lt;&gt; ……） 练习1.查询入职日期最早的员工姓名，入职日期 2.查询工资比SMITH工资高并且工作地点在CHICAGO的员工姓名，工资，部门名称 3.查询入职日期比20部门入职日期最早的员工还要早的员工姓名，入职日期 4.查询部门人数大于所有部门平均人数的部门编号，部门名称，部门人数 ANY 的使用1.查询部门编号不为10，且工资比10部门任意一名员工工资高的员工编号，姓名，职位，工资 ALL的使用1.查询部门编号不为10，且工资比10部门所有员工工资低的员工编号，姓名，职位，工资。 多行子查询子查询返回记录的条数 可以是一条或多条。和多行子查询进行比较时，需要使用多行操作符，多行操作符包括：IN、ANY、ALL。 IN操作符和以前介绍的功能一致，判断是否与子查询的任意一个返回值相同。 练习1.查询入职日期比10部门任意一个员工晚的员工姓名、入职日期，不包括10部门员工 2.查询入职日期比10部门所有员工晚的员工姓名、入职日期，不包括10部门员工 3.查询职位和10部门任意一个员工职位相同的员工姓名，职位，不包括10部门员工 子查询中的空值1.查询不是经理的员工姓名。 问题：子查询返回的结果中含有空值。上面的SQL语句试图查找出没有下属的雇员，逻辑上，这个SQL语句应该会返回8条记录，但是却一条也没返回，why? 因为子查询的结果中有一条空值，这条空值导致主查询没有记录返回。这是因为所有的条件和空值比较结果都是空值。因此无论什么时候只要空值有可能成为子查询结果集合中的一部分，就不能使用NOT IN 运算符。 解决方法 练习1.查询部门平均工资在2500元以上的部门名称及平均工资。 2.查询员工岗位中不是以“SA”开头并且平均工资在2500元以上的岗位及平均工资，并按平均工资降序排序。 3.查询部门人数在2人以上的部门名称、最低工资、最高工资,并对求得的工资进行四舍五入到整数位。 4.查询岗位不为SALESMAN，工资和大于等于2500的岗位及每种岗位的工资和。 5.显示经理号码和经理姓名，这个经理所管理员工的最低工资，没有经理的KING也要显示，不包括最低工资小于3000的，按最低工资由高到低排序。 6.查询工资高于编号为7782的员工工资，并且和7369号员工从事相同工作的员工的编号、姓名及工资。 7.查询工资最高的员工姓名和工资。 8.查询部门最低工资高于10号部门最低工资的部门的编号、名称及部门最低工资。 9.查询员工工资为其部门最低工资的员工的编号和姓名及工资。 10.显示经理是KING的员工姓名，工资。 11.显示比员工SMITH参加工作时间晚的员工姓名，工资，参加工作时间。 "},{"title":"多表连接查询练习","date":"2022-07-15T14:40:16.000Z","url":"/2022/07/15/%E5%A4%9A%E8%A1%A8%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/","tags":[["MySQL","/tags/MySQL/"]],"categories":[["数据库","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"],["MySQL","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"]],"content":"多表连接1.查询每个员工的编号，姓名，工资，工资等级，所在工作城市，按照工资等级进行升序排序。 内连接 tip： inner可以省略。 自身连接1.查询每个员工的姓名和直接上级姓名？ 注：e为员工表，m为上级表；连接的条件是：员工表的上级字段&#x3D;上级表的员工字段 自身连接总结： ​ 自连接 可能看起来有点晦涩难懂，但是实际上换个角度你就会豁然开朗，你可以把它这个过程想象成两张一样的表进行左连接或右连接，这样就会简单多了，其中一张表通过设别名的方式成为了虚表，但是共享原表中的信息。 ​ 应用场景是这样的，就是表的一个字段和另一个字段是相同性质的东西，譬如员工与上司，他们本质也都是员工，在员工表中，员工的直接上司编号会以另一个字段的形式出现，但是他的上司的编号也是会出现在员工编号这个字段里。 ​ 连接操作可以是一个表与自身进行的连接，这时候注意需要为表创建别名 2.查询所有工作在MAN_AGER和CLERK的员工姓名，员工编号，以及他们的经理姓名，经理编号。 注：工作条件也可写成 and (e.job&#x3D;’MAN_AGER’ or e.job&#x3D;’CLERK’) 外部连接​ 在多表连接时，可以使用外部连接来查看哪些行,按照连接条件没有被匹配上。 1. 左外连接​ 左外连接以FROM子句中的左边表为基表，该表所有行数据按照连接条件无论是否与右边表能匹配上，都会被显示出来。 1.查询所有雇员姓名，部门编号，部门名称，包括没有部门的员工也要显示出来 ​ tip：以左表为基表，左表的deptno要全部展示，不考虑右表有的，但左表没有的， 2.使用左连接，查询每个员工的姓名，经理姓名，没有经理的King也要显示出来。 3.使用右连接，查询每个员工的姓名，经理姓名，没有经理的King也要显示出来 2.右外连接​ 右外连接以FROM子句中的右边表为基表，该表所有行数据按照连接条件无论是否与左边表能匹配上，都会被显示出来。 ​ 这里多了三条的原因是：dept部门表有三条数据，分别是deptno&#x3D;40、50、60，但是在emp员工表中并没有deptno的值等于这三个，因此，在进行右外连接的时候，会以右表（dept表为基表），连接左表（emp表），一共展示11+3&#x3D;14条数据。 3.练习1.显示员工SMITH的姓名，部门名称，直接上级名称 2.显示员工姓名，部门名称，工资，工资级别，要求工资级别大于4级。 3.显示员工KING和FORD管理的员工姓名及其经理姓名。 4.显示员工姓名，参加工作时间，经理名，参加工作时间，要求参加时间比经理早。 "},{"title":"日期时间类型函数","date":"2022-07-15T02:02:22.000Z","url":"/2022/07/15/%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B%E6%93%8D%E4%BD%9C/","tags":[["MySQL","/tags/MySQL/"]],"categories":[["数据库","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"],["MySQL","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"]],"content":""},{"title":"check在native中的使用","date":"2022-07-15T01:18:44.000Z","url":"/2022/07/15/check%E5%9C%A8native%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/","tags":[["MySQL","/tags/MySQL/"]],"categories":[["数据库","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"],["MySQL","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"]],"content":"因native版本问题，约束需要手动添加 check: "},{"title":"component组件","date":"2022-07-14T14:46:03.000Z","url":"/2022/07/14/component%E7%BB%84%E4%BB%B6/","tags":[["Vue3","/tags/Vue3/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"],["Vue3","/categories/%E5%89%8D%E7%AB%AF/Vue3/"]],"content":"全局组件全局注册也就是说它们在注册之后可以用在任何新创建的组件实例的模板中 局部变量全局注册往往是不够理想的。比如，如果你使用一个像 webpack 这样的构建系统，全局注册所有的组件意味着即便你已经不再使用其中一个组件了，它仍然会被包含在最终的构建结果中。这造成了用户下载的 JavaScript 的无谓的增加。 注意局部注册的组件在其子组件中不可用。"},{"title":"v-on事件","date":"2022-07-14T11:33:24.000Z","url":"/2022/07/14/%E4%BA%8B%E4%BB%B6/","tags":[["Vue3","/tags/Vue3/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"],["Vue3","/categories/%E5%89%8D%E7%AB%AF/Vue3/"]],"content":"绑定方式 v-on:事件名 @事件名 事件修饰符 .stop 阻止事件冒泡 .prevent 阻止默认事件发生 .capture 使用事件捕获模式 .self 只有元素自身触发事件才执行。（冒泡或捕获的都不执行） .once 只执行一次 ​ 修饰符是由点开头的指令后缀来表示的。 获取事件对象 在调用函数传递特殊变量$event 在函数中直接使用event 按键修饰符（了解） .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 为什么在 HTML 中监听事件？实际上，使用 v-on 或 @ 有几个好处： 扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。 因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。 当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何清理它们。 "},{"title":"v-model表单绑定","date":"2022-07-14T10:59:14.000Z","url":"/2022/07/14/v-model%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A/","tags":[["Vue3","/tags/Vue3/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"],["Vue3","/categories/%E5%89%8D%E7%AB%AF/Vue3/"]],"content":"前面讲解的插值、v-text、v-html都是单向绑定的, 如果需要双向绑定则使用v-model, 因为是双向绑定, 意味着可以在视图中修改数据。 基础用法​ 在表单控件或者组件上创建双向绑定。它会根据控件类型自动选取正确的方法来更新元素。 提示： ​ v-model 会忽略所有表单元素的 value、checked、selected attribute 的初始值。它将始终将当前活动实例的数据作为数据来源。你应该通过 JavaScript 在组件的 data 选项中声明初始值。 修饰符 v-model.lazy 只有在input输入框发生一个blur时才触发，也就是延迟同步到失去焦点时 v-model.trim 将用户输入的前后的空格去掉 v-model.number 将用户输入的字符串转换成number "},{"title":"MySQL常用函数","date":"2022-07-14T06:41:31.000Z","url":"/2022/07/14/SQL%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/","tags":[["MySQL","/tags/MySQL/"]],"categories":[["数据库","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"],["MySQL","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"]],"content":"一、MySQL函数概述​ MySQL提供了很多功能强大、方便易用的函数，在进行数据库管理以及数据的查询和操作时，帮助我们提高对数据库的管理效率。 ​ 函数分类： 单行、多行函数。 二、单行函数语法2.1 语法:​ 函数名[(参数1，参数2,…)] 其中的参数可以是以下之一：变量、列名、表达式 2.2 单行函数特征 单行函数对单行操作 每行返回一个结果 有可能返回值与原参数数据类型不一致 单行函数可以写在SELECT、WHERE、ORDER BY子句中 有些函数没有参数，有些函数包括一个或多个参数 函数可以嵌套 三、常用函数分类 数学函数 字符串函数 日期和时间函数 流程控制函数 其他函数 3.1 数学函数 abs() 求绝对值 pi() 返回pi sqrt(x) 开平方根 mod(x) 求余数 ceil(x)\\ceiling(x) 向上取整 floor(x) 向下取整 round() 四舍五入取整 round(x,y) 四舍五入保留小数点y位取整 truncate(x,y) 截断 rand() 返回随机数？ sign(x) 返回符号为,整数返回1负数返回-1,0就返回0 pow(x,y)\\power(x,y) 返回x数据求y次方后的结果 3.2 字符串函数 char_length(x) 求字符的个数 length(x) 返回字节个数 concat(str1,str2,…) 字符串拼接,如果有一个参数是null那么全部返回都是null concat_ws(sepe0rator,str1,str2,…) 字符串拼接,拼接的分隔符使用seperator,如果被拼接的参数是null,则会忽略 insert(str,position,len,newStr) 在str的指定位置开始取len个字符并用newStr来代替 lower(x) 转成小写 upper(x) 转成大写 left(str,len) 返回字符串str的左边开始计算共返回len个字符 right(str,len) 返回字符串str的右边开始计算共返回len个字符 lpad(str,len,newStr) 对str的左边开始用newStr填充直到填充后的字符串长度为len为止 rpad(str,len,newStr) 对str的右边开始用newStr填充直到填充后的字符串长度为len为止 ltrim(x) 去除字符串x的左边空格 rtrim(x) 去除字符串x的右边空格 trim(x) 去除字符串x左右两边的隔空 trim( delStr from str) 去除字符串str中左右两边的delStr字符串 repeat(str,times) 返回一个新字符串,该字符串由于字符串str重复times次组成 space(n) 返回n个由于空格组成的字符串 replace(str,source,target) 返回str字符串中source子串被target字符串替换的结果 strcmp(x,y) 返回字符串x和y的比较结果,如果是相等返回0,x大于y返回1,否则返回-1 substring(str,startPosition[,len]) 如果len没有写,返回的是字符串str中从startPosition开始截取到末尾字符串 如果len有指定,返回的是字符串str中从stratPosition开始截取len个字符串 reverse(x) 对字符串x逆序(倒序) ELT(position,str1,str2,…) 返回的是参数中str1,str2,…参数中第position个位置的字符串 3.3 日期和时间函数 CURDATE()和CURRENT_DATE() ：获取当前日期函数; NOW()：返回服务器的当前日期和时间； CURTIME(）：返回当前时间，只包含时分秒； UTC_DATE(）：返回世界标准时间日期函数； UTC_TIME()：返回世界标准时间函数； TIMEDIFF(expr1, expr2)：返回两个日期相减相差的时间数； DATEDIFF(expr1, expr2)：返回两个日期相减相差的天数； DATE_ADD(date,INTERVAL expr type):日期加上一个时间间隔值； DATE_SUB(date,INTERVAL expr type):日期减去一个时间间隔值； DATE(date)、TIME(date)、YEAR（date）：选取日期时间的各个部分： EXTRACT(unit FROM date)：从日期中抽取出某个单独的部分或组合； DAYOFWEEK(date) 、DAYOFMONTH(date) 、DAYOFYEAR(date):返回日期 在一周、一月、一年中是第几天 DAYNAME、MONTHNAME：返回日期的星期和月份名称； DATE_FORMAT(date,format)：格式化日期； TIME_FORMATE(time,formate）：格式化时间； （下一篇 ….） 四、其它函数 database() 获取当前使用的数据库实例名 version() 获取数据的版本 user() 获取当前登录用户 md5(明文) 获取明文MD5后的摘要信息 password(明文) 获取明文加密后的密文,mysql使用该函数加密用户的密码 案例"},{"title":"day-01","date":"2022-07-14T02:30:49.000Z","url":"/2022/07/14/day-01/","tags":[["MySQL","/tags/MySQL/"]],"categories":[["数据库","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"],["MySQL","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"]],"content":"常见概念数据库数据库管理系统数据库管理员常见操作 登录 退出 数据库实例操作 表操作 表的操作新建语法 案例 复制表 方式一 方式二 修改列 添加列 修改列 删除列 常见的约束 主键 含义:用来区分表中记录数的一列或多列(此时一般称为复合主键) 特点:非空且唯一 外键 含义:表中的一列的值是来自其他表中的主键或唯一列 特点:值只能是引用列的值或为null(前提设置可以为空) NOT NULL 含义:列的值不能为空 UNIQUE 含义:表中的指定的unique的列必须是唯一的 特点:可以为null ENUM SET CHECK 语法 修改约束 添加约束 删除约束 案例TODO 修改表名语法 案例 DML含义数据操作语言 分类 insert update delete insert 语句语法 插入一条记录 批量插入 案例 update语句语法 案例 delete语句语法 案例 DDL含义数据定义语言,比如:create table、create view、truancate等等 truncate含义截断表 和delete区别 truncate是DDL语言,delete是DML语言 truncate只能删除表中的全部记录,delete可以指定删除记录 trancate会是否表空间,delete不会是否表空间 trancate不能回滚,delete可以回滚 "},{"title":"SQL分类","date":"2022-07-14T01:33:59.000Z","url":"/2022/07/14/SQL%E5%88%86%E7%B1%BB/","tags":[["MySQL","/tags/MySQL/"]],"categories":[["数据库","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"],["MySQL","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"]],"content":"一、SQL分类 DDL(Data Definition Languages)语句：数据定义语言，这些语句定义了不同的数据段、数据库、表、列、索引等数据库对象。常用的语句关键字主要包括create、drop、alter等。 DML(Data Manipulation Languages)语句：数据操纵语句，用于添加、删除、更新和查询数据库记录，并检查数据完整性。常用的语句关键字主要包括insert、delete、update和select等。 DCL（Data Control Language）语句：数据控制语句，用于控制不同数据段直接的许可和访问级别的语句，这些语句定义了数据库、表、字段、用户的访问权限和安全级别，主要的语句关键字包括grant、revoke等。 ​ DQL：数据查询语言。select…… 1.1 DDL语句 DDL是数据定于语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改等操作的语言。它和DML语言的最大区别是DML只是对表内部数据操作，而不涉及表的定义，结构的修改，更不会涉及其他对象。DDL语句更多的由数据库管理员（DBA）使用，开发人员一般很少使用。 1.2 DQL语句语法： 1.2.1 列别名 列别名 用来重新命名列的显示标题 如果SELECT语句中包含计算列，通常使用列别名来重新定义列标题。 使用列别名的方法 方式1：列名 列别名 方式2：列名 AS 列别名 以下三种情况列别名两侧需要添加双引号列别名中包含有空格列别名中要求区分大小写(ORACLE中)列别名中包含有特殊字符 列别名使用 例如： 查询员工年薪，并给新的列起别名yearSal（不会改变原来的表数据） (as 可以省略) 1.2.2 消除重复行 重复行 以下查询的结果默认输出所有行，其中包含了重复行 消除重复行 在SELECT字句中使用关键字DISTINCT可消除重复行。 1.2.3 比较操作符​ （不等于符号是 ‘&lt;&gt;’） 比较字符型数据 字符型数据作为被比较的值时，必须用单引号引起来 字符型数值区分大小写(MySQL不区分，Oracle区分) 比较日期型数据 日期型数值作为被比较的值时，必须用单引号引起来。 1.2.4 特殊比较运算符 运算符 含义 BETWEEN…AND… 判断要比较的值是否在某个范围内。 IN（ 集合列表） 判断要比较的值是否和集合列表中的任何一个值相等。 LIKE 判断要比较的值是否满足部分匹配 IS NUL 判断要比较的值是否为空值NULL BETWEEN..AND.. 使用BETWEEN .. AND.. 运算符来判断要比较的值是否在某个范围内。 查询薪水在1000-1500（包含1000、1500）范围内的员工的姓名跟薪水 IN运算符 使用IN运算符判断要比较的值是否和集合列表中的任何一个值相等。 LIKE运算符 使用LIKE运算符判断要比较的值是否满足部分匹配，也叫模糊查询。模糊查询中两个通配符： % 代表零或任意更多的字符 _ 代表一个字符 查询S开头的名字： MySQL中ESCAPE关键字: ESCAPE 关键字的主要作用就是指定一个字符替代转义字符“\\”的作用。 转义即表示转义字符原来的语义，一个转义字符的目的是开始一个字符序列，使得转义字符开头的该字符序列具有不同于该字符序列单独出现时的语义。 1.2.5 运算符的优先级 括号’()’优先于其他操作符。 优先级 运算分类 运算符举例 1 算术运算符 *, , +, - 2 比较运算符 &#x3D;, &lt;&gt;, &lt;, &gt;, &lt;&#x3D;, &gt;&#x3D; 3 特殊比较运算符 BETWEEN..AND.. ,IN,LIKE,IS NULL 4 逻辑非 NOT 5 逻辑与 AND 6 逻辑或 OR 1.2.6 ORDER BY子句 使用ORDER BY子句能对查询结果集进行排序,语法结构如下： 其中： 可以按照列名、表达式、列别名、结果集的列序号排序 ASC: 升序(默认值), DESC: 降序 ORDER BY 子句必须写在SELECT语句的最后 1.3 DML一些基础操作在Mysql练习-01"},{"title":"Data、Vue方法、计算属性及监听器","date":"2022-07-13T11:12:55.000Z","url":"/2022/07/13/Data-Property-%E5%92%8C%E6%96%B9%E6%B3%95/","tags":[["Vue3","/tags/Vue3/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"],["Vue3","/categories/%E5%89%8D%E7%AB%AF/Vue3/"]],"content":"一、Data函数该函数返回组件实例的 data 对象。Vue 会在创建新组件实例的过程中调用此函数。它应该返回一个对象，然后 Vue 会通过响应性系统将其包裹起来，并以 $data 的形式存储在组件实例中。为方便起见，该对象的任何顶级 property 也会直接通过组件实例暴露出来。 实例创建之后，可以通过 vm.$data 访问原始数据对象。组件实例也代理了 data 对象上所有的 property，因此访问 vm.a 等价于访问 vm.$data.a。 注：以 _ 或 $ 开头的 property 不会被组件实例代理，因为它们可能和 Vue 内置的 property、API 方法冲突。你可以使用例如 vm.$data._property 的方式访问这些 property。 二、methods方法我们用 methods选项向组件实例添加方法，这个methods方法是一个包含我们所需方法的对象： Vue 自动为 methods 绑定 this，以便于它始终指向组件实例。这将确保方法在用作事件监听或回调时保持正确的 this指向。 在定义 methods 时应避免使用箭头函数，因为这会阻止 Vue 绑定恰当的 this 指向。 三、 computed监听计算属性的结果会被缓存，只有当依赖的响应式 property 变化时才会重新计算。注意，如果某个依赖 (比如非响应式 property) 在该实例范畴之外，则计算属性是不会被更新的。 3.1 计算属性是根据依赖关系进行缓存的计算，并且只在需要的时候进行更新。 3.2 对数据进行过滤处理 四、methods方法与computed计算属性的区别虽然使用computed和methods方法两种方法实现一个功能的结果是相同的，但本质是不一样的。 计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变的时候才会重新求值，这就意味着只要message还没有发生改变，多次访问reversedMessage计算属性立即返回的是之前计算的结果，而不会再次执行计算函数。 而对于methods方法，只要发生重新渲染，methods调用总会执行该函数。 如果某个computed需要的遍历一个极大的数组和做大量的计算，可以减小性能开销，如果不希望有缓存，则用methods。 五、watch 监听器watch能够监听数据的改变。监听之后会调用一个回调函数。此回调函数的参数有两个： 更新后的值（新值） 更新前的值（旧值） 5.1 浅度监听下面使用watch来监听商品数量的变化。如果商品数量小于1，就重置成上一个值。 5.2 深度监听在上面的例子中，监听的简单的数据类型，数据改变很容易观察，但是当需要监听的数据变为对象类型的时候，上面的监听方法就失效了，因为上面的简单数据类型属于浅度监听，对应的对象类型就需要用到深度监听，只需要在上面的基础上加上deep: true就可以了。 5.2.1 错误示例 上面代码中，由于监听的是对象类型，所以 newVal 与 oldVal 都指向同一个对象。 所以，在深度监听对象时，是不能正确获取更新前的对象和更新后的对象的，所以会出现数量为负数的情况。 5.2.2 解决方案利用计算属性将对象变成字符串后再监听。 "},{"title":"MySQL约束","date":"2022-07-13T07:47:53.000Z","url":"/2022/07/13/MySQL%E7%BA%A6%E6%9D%9F/","tags":[["MySQL","/tags/MySQL/"]],"categories":[["数据库","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"],["MySQL","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"]],"content":"在 SQL 中，我们有如下约束： NOT NULL - 指示某列不能存储 NULL 值。 UNIQUE - 保证某列的每行必须有唯一的值。 PRIMARY KEY - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。 FOREIGN KEY - 保证一个表中的数据匹配另一个表中的值的参照完整性。 CHECK - 保证列中的值符合指定的条件。 DEFAULT - 规定没有给列赋值时的默认值。 一、命令行 一、约束概述 约束： Constraint，是定义在表上的一种强制规则。 当为某个表定义约束后，对该表做的所有SQL操作都必须满足约束的规则要求，否则操作将失败。 非空约束（NOT NULL） 强制列不能为 NULL 值，约束强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或者更新记录。 "},{"title":"Mysql练习-01","date":"2022-07-13T06:40:34.000Z","url":"/2022/07/13/Mysql%E7%BB%83%E4%B9%A0/","tags":[["MySQL","/tags/MySQL/"]],"categories":[["数据库","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"],["MySQL","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"]],"content":"喵呼呼o(&#x3D;•ェ•&#x3D;)m 一、timestamp时间戳类型：在进行添加、修改操作（insert、update）的时候，时间会自动进行修改。 在设计表的时候进行设计timestamp类型，可设置默认值为（CURRENT_TIMESTAMP）当前时间戳。 二、enum枚举类型例如：设置season季节字段为enum类型，值为（’春’,’夏’,’秋’,’冬’） 输入数字，会对应值列表的索引进行匹配，如我输入1，会给我选择‘春’，4就是 ‘冬’； 输入其它会报错。 三、check检查约束如: 当我输入的年龄在100以内可以，否则会报1264 - Out of range value for column ‘age’ at row 1 的越界错误信息。 四、DML操作1&#x2F;2: 3.使用如下语句，建立以下表 (1)在表copy_emp中插入数据，要求sal字段插入空值，部门号50，参加工作时间为2000年1月1日，其他字段随意 (2)在表copy_emp中插入数据，要求把emp表中部门号为10号部门的员工信息插入 注： 我们可以从一个表中复制所有的列插入到另一个已存在的表中： INSERT INTO table2 SELECT * FROM table1; 或者我们可以只复制希望的列插入到另一个已存在的表中： insert into copy_emp (empno, ename, hiredate, deptno, sal) select empno, ename, hiredate, deptno, sal from emp where deptno &#x3D; 10; (3)修改copy_emp表中数据，要求10号部门所有员工涨20%的工资 "},{"title":"axios学习","date":"2022-06-27T02:02:34.000Z","url":"/2022/06/27/axios%E5%AD%A6%E4%B9%A0/","tags":[["axios","/tags/axios/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"],["axios","/categories/%E5%89%8D%E7%AB%AF/axios/"]],"content":"一、axios响应数据结构 vue.config.js DevView.vue 二、测试后台接口： "},{"title":"Vue3生命周期钩子","date":"2022-06-26T03:22:29.000Z","url":"/2022/06/26/Vue3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90/","tags":[["Vue3","/tags/Vue3/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"],["Vue3","/categories/%E5%89%8D%E7%AB%AF/Vue3/"]],"content":"每个组件在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。 也有一些其它的钩子，在实例生命周期的不同阶段被调用，如 [mounted]、[updated]， [unmounted]。生命周期钩子的 this 上下文指向调用它的当前活动实例。 tip 不要在选项 property 或回调上使用箭头函数 ，比如 created: () =&gt; console.log(this.a) 或 vm.$watch(&#39;a&#39;, newValue =&gt; this.myMethod())。因为箭头函数并没有 this，this 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 Uncaught TypeError: Cannot read property of undefined 或 Uncaught TypeError: this.myMethod is not a function 之类的错误。"},{"title":"vue3_创建","date":"2022-06-26T02:47:49.000Z","url":"/2022/06/26/vue3-%E5%88%9B%E5%BB%BA/","tags":[["vue3","/tags/vue3/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"],["Vue3","/categories/%E5%89%8D%E7%AB%AF/Vue3/"]],"content":""},{"title":"vue3入门","date":"2022-06-25T13:13:10.000Z","url":"/2022/06/25/vue3%E5%85%A5%E9%97%A8/","tags":[["Vue3","/tags/Vue3/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"],["Vue3","/categories/%E5%89%8D%E7%AB%AF/Vue3/"]],"content":"一、声明式渲染 声明式渲染 二、v-bind v-bind测试 三、v-on v-on测试 四、v-if v-if测试 五、v-for v-for 六、v-model v-model "},{"title":"Validated数据校验[未完]","date":"2022-06-25T01:27:56.000Z","url":"/2022/06/25/Validated%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/","tags":[["springboot2","/tags/springboot2/"]],"categories":[["springboot2","/categories/springboot2/"],["springboot2入门","/categories/springboot2/springboot2%E5%85%A5%E9%97%A8/"]],"content":"SR-303：它是一项 Bean Validation 校验标准，规定了一些校验规范，比如@Null，@NotNull，@Pattern，相关注解都位于javax.validation.constraints包下。需要注意的是，[JSR-303]只提供校验规范，不提供实现。 而在 Spring 中，其也提供了相应的 Bean Validation 实现：Java Bean Validation。 一、添加依赖 字符串&#x2F;数组&#x2F;集合检查：(字符串本身就是个数组)@Pattern(regexp&#x3D;”reg”) 验证字符串满足正则@Size(max, min) 验证字符串、数组、集合长度范围@NotEmpty 验证字符串不为空或者null@NotBlank 验证字符串不为null或者trim()后不为空 数值检查：同时能验证一个字符串是否是满足限制的数字的字符串@Max 规定值得上限int@Min 规定值得下限@DecimalMax(“10.8”) 以传入字符串构建一个BigDecimal，规定值要小于这个值@DecimalMin 可以用来限制浮点数大小@Digits(int1, int2) 限制一个小数，整数精度小于int1；小数部分精度小于int2@Digits 无参数，验证字符串是否合法@Range(min&#x3D;long1,max&#x3D;long2) 检查数字是否在范围之间这些都包括边界值 日期检查：Date&#x2F;Calendar@Post 限定一个日期，日期必须是过去的日期@Future 限定一个日期，日期必须是未来的日期 其他验证：@Vaild 递归验证，用于对象、数组和集合，会对对象的元素、数组的元素进行一一校验@Email 用于验证一个字符串是否是一个合法的右键地址，空字符串或null算验证通过@URL(protocol&#x3D;,host&#x3D;,port&#x3D;,regexp&#x3D;,flags&#x3D;) 用于校验一个字符串是否是合法URL 二、MethodArgumentNotValidException异常 MethodArgumentNotValidException（@Validated @Valid 前端提交的方式为json格式有效，出现异常时会被该异常类处理） 2022-06-25 15:52:31.070 WARN 4244 — [nio-8081-exec-2] .m.m.a.ExceptionHandlerExceptionResolver : Resolved [org.springframework.web.bind.MethodArgumentNotValidException: Validation failed for argument [0] in public com.example.testspringboot.domain.User com.example.testspringboot.controller.HelloController.validataedTest(com.example.testspringboot.domain.User): [Field error in object ‘user’ on field ‘password’: rejected value [1]; codes [Length.user.password,Length.password,Length.java.lang.String,Length]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [user.password,password]; arguments []; default message [password],6,3]; default message [pwd需要3-6位]] ] 以上参数： objectName - 受影响对象的名称 code- 用于解决此消息的代码 arguments - 用于解析此消息的参数数组 defaultMessage - 用于解析此消息的默认消息 三、示例"},{"title":"data注解","date":"2022-06-24T12:38:07.000Z","url":"/2022/06/24/data%E6%B3%A8%E8%A7%A3/","tags":[["springboot2","/tags/springboot2/"]],"categories":[["springboot2","/categories/springboot2/"],["springboot2入门","/categories/springboot2/springboot2%E5%85%A5%E9%97%A8/"]],"content":"@Data注解的主要作用是提高代码的简洁，使用这个注解可以省去实体类中大量的get()、 set()、 toString()等方法。 一、导入依赖 可以在IDEA编译器中添加lombok插件，File -&gt; Setting -&gt; Plugins -&gt; 搜索lombok 二、其他相关注解 @Data ： 注在类上，提供类的get、set、equals、hashCode、toString等方法 @AllArgsConstructor ：注在类上，提供类的全参构造 @NoArgsConstructor ：注在类上，提供类的无参构造 @Setter ：注在属性上，提供 set 方法 @Getter ：注在属性上，提供 get 方法 @EqualsAndHashCode ：注在类上，提供对应的 equals 和 hashCode 方法 @Log4j&#x2F;@Slf4j ：注在类上，提供对应的 Logger 对象，变量名为 log 三、测试"},{"title":"springboot-拦截器","date":"2022-06-16T13:42:32.000Z","url":"/2022/06/16/springboot-%E6%8B%A6%E6%88%AA%E5%99%A8/","tags":[["springboot2","/tags/springboot2/"]],"categories":[["springboot2","/categories/springboot2/"],["springboot2入门","/categories/springboot2/springboot2%E5%85%A5%E9%97%A8/"]],"content":"Web开发中，我们除了使用 Filter 来过滤请web求外，还可以使用Spring提供的HandlerInterceptor（拦截器）。 HandlerInterceptor 的功能跟过滤器类似，但是提供更精细的的控制能力：在request被响应之前、request被响应之后、视图渲染之前以及request全部结束之后。我们不能通过拦截器修改request内容，但是可以通过抛出异常（或者返回false）来暂停request的执行。 一、实现自定义拦截器只需要3步：1、创建我们自己的拦截器类并实现 HandlerInterceptor 接口。2、创建一个Java类继承WebMvcConfigurerAdapter，并重写 addInterceptors 方法。2、配置拦截规则（在addInterceptors方法中添加）。 MyInterceptor1. JAVA MyInterceptor2 . JAVA MyWebAppConfigurer . java 注解一定要通过addPathPatterns来指定该拦截器所拦截的URL，如果不指定将不会拦截任何请求。 测试结果： MyInterceptor1&gt;&gt;&gt;&gt;&gt;&gt;&gt;在请求处理之前进行调用（Controller方法调用之前）MyInterceptor2&gt;&gt;&gt;&gt;&gt;&gt;&gt;在请求处理之前进行调用（Controller方法调用之前）MyInterceptor2&gt;&gt;&gt;&gt;&gt;&gt;&gt;请求处理之后进行调用，但是在视图被渲染之前（Controller方法调用之后）MyInterceptor1&gt;&gt;&gt;&gt;&gt;&gt;&gt;请求处理之后进行调用，但是在视图被渲染之前（Controller方法调用之后）MyInterceptor2&gt;&gt;&gt;&gt;&gt;&gt;&gt;在整个请求结束之后被调用，也就是在DispatcherServlet 渲染了对应的视图之后执行（主要是用于进行资源清理工作）MyInterceptor1&gt;&gt;&gt;&gt;&gt;&gt;&gt;在整个请求结束之后被调用，也就是在DispatcherServlet 渲染了对应的视图之后执行（主要是用于进行资源清理工作） 二、拦截器链： 三、WebMvcConfigurerWebMvcConfigurer主要是提供接口来实现SpringMVC的自定义配置，其中它与Interceptor相关的就是addInterceptors方法，通过覆盖该方法，可以添加自定义Interceptor。 "},{"title":"springboot-日志的级别","date":"2022-06-16T12:43:39.000Z","url":"/2022/06/16/springboot-%E6%97%A5%E5%BF%97%E7%9A%84%E7%BA%A7%E5%88%AB/","tags":[["springboot2","/tags/springboot2/"]],"categories":[["springboot2","/categories/springboot2/"],["springboot2入门","/categories/springboot2/springboot2%E5%85%A5%E9%97%A8/"]],"content":"测试 运行打开控制台可以看到打印的日志出现的级别有info，warn，error，其它的都没有出现。 "},{"title":"java自定义异常处理","date":"2022-05-29T05:55:41.000Z","url":"/2022/05/29/java%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","categories":[["javaweb","/categories/javaweb/"]],"content":"​ 使用 Java 内置的异常类可以描述在编程时出现的大部分异常情况。除此之外，用户还可以自定义异常。用户自定义异常类，只需继承Exception类即可。 实际应用中的经验总结 处理运行时异常时，采用逻辑去合理规避同时辅助try-catch处理 在多重catch块后面，可以加一个catch(Exception)来处理可能会被遗漏的异常 对于不确定的代码，也可以加上try-catch，处理潜在的异常 尽量去处理异常，切忌只是简单地调用printStackTrace()去打印输出 具体如何处理异常，要根据不同的业务需求和异常类型去决定 尽量添加finally语句块去释放占用的资源。 情况一：某些时候后台出现了异常，直接给前端抛了一个500错误，这种错误会被用户看到非常不友好，于是就有了以下统一异常处理，就是把所有的异常都经过处理，按照前端可读的json格式返回。 情况二：如果service业务层方法出现任何业务异常，则返回标记（自定义异常 ）到web层（servlet） service层： controller层： 测试结果： 整个运行过程中虽然会抛出咱们自定义的异常但不会中断程序，能向客户端发送异常信息。 代码： 测试： "},{"title":"vue cli - 创建脚手架","date":"2022-05-17T11:16:04.000Z","url":"/2022/05/17/vue-cli-%E5%88%9B%E5%BB%BA%E8%84%9A%E6%89%8B%E6%9E%B6/","tags":[["Vue3","/tags/Vue3/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"],["Vue3","/categories/%E5%89%8D%E7%AB%AF/Vue3/"]],"content":"一、准备​ 先下载完node， 按照完成后打开cmd命令行工具输入node -v， 如果显示版本号说明安装成功，如： 显示出npm的版本信息: 安装cnpm： 使用cnpm的方法就是，需要用到npm的地方直接使用cnpm替换就可以了。 安装最新@vue&#x2F;cli版本： 安装完成后，使用 vue -V 显示版本号来测试vue是否安装成功。 二、创建脚手架 在idea里面打开文件夹 三、终端打开、下载卡住 清理缓存 四、安装element-plus"},{"title":"组件基础","date":"2022-05-13T01:36:59.000Z","url":"/2022/05/13/%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/","categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"],["Vue","/categories/%E5%89%8D%E7%AB%AF/Vue/"]],"content":"组件名大小写定义组件名的方式有两种： 使用 kebab-case： 使用 PascalCase: 当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。也就是说 和 都是可接受的。注意，尽管如此，直接在 DOM (即非字符串的模板) 中使用时只有 kebab-case 是有效的。 案例 运行截图： ​ 组件是可复用的 Vue 实例，且带有一个名字：在这个例子中是 &lt;button-counter&gt;。我们可以在一个通过 new Vue 创建的 Vue 根实例中，把这个组件作为自定义元素来使用： 组件的复用你可以将组件进行任意 次数的复用：注意当点击按钮时，每个组件都会各自独立维护它的 count。因为你每用一次组件，就会有一个它的新实例被创建。 选项必须是一个函数因此每个实例可以维护一份被返回对象的独立的拷贝： 如果 Vue 没有这条规则，点击一个按钮就可能会几个按钮同时显示同一个值，互相影响。 组件的组织了能在模板中使用，这些组件必须先注册以便 Vue 能够识别。这里有两种组件的注册类型：全局注册和局部注册。 全局组件至此，我们的组件都只是通过 Vue.component 全局注册的： 我们可以总结出全局组件的使用步骤： 使用vue.component()注册组件，需要提供2个参数：组件的标签名和组件构造器。 vue.component()内部会调用组件构造器，创建一个组件实例 将组建挂载到某个vue实例下。 注意：一个组件的template部分，必须要包裹在一个根容器中。 因为组件是可复用的vue实例，所以它们也能有data、computed、watch、methods以及生命周期钩子等。 组件模板的内容，可以写在一对反引号中（&#96;&#96;），这样就可以不使用字符串拼接的形式了。 局部组件如果不需要全局注册，或者是让组件使用在其它组件内，可以用选项对象的components属性实现局部注册。 因此我们可以将上面的全局组件改为局部组件。 组件模板如果组件中的template内容过多，那么可以使用组件模板来声明template中的内容 父子组件当我们继续在组件中写组件，形成组件嵌套的时候，就是我们所说的父子组件了 组件之间的通信组件与组件之间是可以互相通信的。包括父子组件之间、兄弟组件之间等等，都可以互相通信。 下面只讨论父子组件之间通信问题。 子组件获取父组件数据在vue中，组件实例的作用域是孤立的，默认情况下，父子组件的数据是不能共享的，也就是说，子组件是不能直接访问父组件的数据的。为此，vue给我们提供了一个数据传递的选项prop，用来将父组件的数据传递给子组件。具体使用如下： 上面实例中，子组件获取父组件传递的数据的步骤为： 在子组件标签中，声明 msg 属性，属性值即为父组件向子组件传递的值。 在子组件中，使用props选项，声明接收父组件向子组件传递值的载体，即 ‘msg’ 。 子组件中就可以使用 msg 获取父组件向子组件传递的值了。 也可以使用 v-bind 绑定子组件标签属性，这样就可以将父组件data数据传递个子组件了。 父组件获取子组件数据和上面不一样的是，父组件想要获取子组件的数据时，需要子组件通过emit主动将自己的数据发送给父组件。 首先，我们需要在子组件中触发一个主动发送数据的事件，上面的例子中是一个点击事件send； 其次，在点击事件中使用emit方法，这个emit接收两个参数：传递数据的事件和需要传递的数据，这个传递数据的事件也是自定义的； 然后在父组件中引用子组件，并在引用的子组件中使用on监听上一步传递数据的事件，上面的例子中是childmsg； 最后在父组件中使用这个事件，这个事件带有一个参数，就是从子组件发送过来的数据。 "},{"title":"v-on事件处理","date":"2022-05-10T15:29:03.000Z","url":"/2022/05/10/v-on%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/","categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"],["Vue","/categories/%E5%89%8D%E7%AB%AF/Vue/"]],"content":"一、事件处理方法 二、内联处理器的方法 三、事件修饰符在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。 为了解决这个问题，Vue为 v-on 提供了事件修饰符。修饰符是由点开头的指令后缀来表示的。 .stop .prevent .capture .self .once .passive 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。 因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。 这个 .passive 修饰符尤其能够提升移动端的性能。 注意： 不要把 .passive 和 .prevent一起使用，因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，.passive 会告诉浏览器你不想阻止事件的默认行为。 按键修饰符 略》。。。。"},{"title":"侦听数组的变更方法（触发视图更新）","date":"2022-05-10T14:43:51.000Z","url":"/2022/05/10/%E4%BE%A6%E5%90%AC%E6%95%B0%E7%BB%84%E7%9A%84%E5%8F%98%E6%9B%B4%E6%96%B9%E6%B3%95%EF%BC%88%E8%A7%A6%E5%8F%91%E8%A7%86%E5%9B%BE%E6%9B%B4%E6%96%B0%EF%BC%89/","categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"],["Vue","/categories/%E5%89%8D%E7%AB%AF/Vue/"]],"content":"由于 JavaScript 的限制，Vue 不能检测数组和对象的变化, 比如：将数组的长度设置为0后，数组确实被清空了。但是Vue却不能检测到数组的变化，所以页面视图也不会响应。 为了解决这个问题，我们可以通过使用下列方法触发视图更新！ 变更方法这些方法包括： push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。 pop() 方法用于删除并返回数组的最后一个元素。 shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。 unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。 splice() 方法向&#x2F;从数组中添加&#x2F;删除项目，然后返回被删除的项目。 sort() 方法用于对数组的元素进行排序。 reverse() 方法用于颠倒数组中元素的顺序。 你可以打开控制台，然后对items 数组尝试调用变更方法。比如 vm.items.push(&#123; message: &#39;Baz&#39; &#125;)。 替换数组​ 变更方法，顾名思义，会变更调用了这些方法的原始数组。相比之下，也有非变更方法，例如 ： filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。 concat() 方法用于连接两个或多个数组。 slice() 方法可从已有的数组中返回选定的元素。 它们不会变更原始数组，而总是返回一个新数组。当使用非变更方法时，可以用新数组替换旧数组： ​ 你可能认为这将导致 Vue 丢弃现有 DOM 并重新渲染整个列表。幸运的是，事实并非如此。Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的启发式方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。 其他split() 方法用于把一个字符串分割成字符串数组。 显示过滤&#x2F;排序后的结果有时，我们想要显示一个数组经过过滤或排序后的版本，而不实际改变原始数据。在这种情况下，可以创建一个计算属性，来返回过滤或排序后的数组。 1. 使用计算属性computed 测试结果：2 4 注： 返回偶数数据 2. 在计算属性不适用的情况下 (例如，在嵌套 v-for 循环中) 你可以使用一个方法： 注： even(set) 调用vue里的方法，参数为外层循环遍历sets的某一层的迭代数据set。 测试结果： 2 4 6 8 10 "},{"title":"v-for遍历","date":"2022-05-10T14:20:14.000Z","url":"/2022/05/10/v-for%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0/","categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"],["Vue","/categories/%E5%89%8D%E7%AB%AF/Vue/"]],"content":"​ vue.js 的循环渲染是依赖于 v-for 指令，它能够根据 vue 的实例里面的信息，循环遍历所需数据，然后渲染出相应的内容。 ​ 它可以遍历数组类型以及对象类型的数据，js 里面的数组本身实质上也是对象，这里遍历数组和对象的时候，方式相似但又稍有不同。 我们可以用 v-for 指令基于一个数组来渲染一个列表。v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组，而 item 则是被迭代的数组元素的别名。 一、遍历对象 value 是遍历得到的属性值 key 是遍历得到的属性名， index 是遍历当前项的索引 [ key : value ] 键值对形式 这里的 key、index 都是可选参数，如果不需要，这个指令其实可以写成 v-for&#x3D;”value in user”； 测试结果： 0：userId：1 1：userName：张三 2：userSex：男 1 张三 男 二、遍历数组元素value 是遍历得到的元素，index 是数组下标，这里的index 也是可选参数，如果不需要，这个指令其实可以写成 v-for&#x3D;”value in userArr”； 测试结果： 1, 张三, 男 操作 2, 李四, 女 操作 3, 王五, 男 操作 注： 你也可以用 of 替代 in 作为分隔符，因为它更接近 JavaScript 迭代器的语法 如： 三、:key&#x3D;”item.id”​ 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性： ​ 建议尽可能在使用 v-for 时提供 key 属性，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。 注意：不要使用对象或数组之类的非基本类型值作为 v-for 的 key键。请用字符串或数值类型的值。 四、 在template上使用可以利用带有 v-for 的 &lt;template&gt; 来循环渲染一段包含多个元素的内容。比如： 五、v-for 与 v-if 一同使用不推荐在同一元素上使用 v-if 和 v-for。 当它们处于同一节点，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。当你只想为部分项渲染节点时，这种优先级的机制会十分有用，如下： 上面的代码将只渲染未完成的 todo。 而如果你的目的是有条件地跳过循环的执行，那么可以将 v-if 置于外层元素 (或 template标签上。如： 六、在组件上使用 v-for在自定义组件上，你可以像在任何普通元素上一样使用 v-for。 2.2.0+ 的版本里，当在组件上使用 v-for 时，key 现在是必须的。 然而，任何数据都不会被自动传递到组件里，因为组件有自己独立的作用域。为了把迭代数据传递到组件里，我们要使用 prop"},{"title":"v-if 与 v-show","date":"2022-05-10T13:54:52.000Z","url":"/2022/05/10/v-if-%E4%B8%8E-v-show/","categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"],["Vue","/categories/%E5%89%8D%E7%AB%AF/Vue/"]],"content":"v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染并保留在 DOM 中，只是简单地基于 CSS 进行切换。 v-show 是简单地切换元素的 CSS 属性 display (如内联样式可以看得到display &#x3D; none， 而 v-if 是啥也没有)。 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。 因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。"},{"title":"Vue实例","date":"2022-05-09T11:39:45.000Z","url":"/2022/05/09/Vue%E5%AE%9E%E4%BE%8B/","categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"],["Vue","/categories/%E5%89%8D%E7%AB%AF/Vue/"]],"content":"现在算来已经有四个月没学习vue了，这段时间大部分都用在spring框架上，vue忘的也差不多了，但今天重新启航！开卷！ 一、创建一个Vue实例​ 当一个 Vue 实例被创建时，它将 data对象中的所有的 属性都会加入到 Vue 的响应式系统中。当这些 属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。 ​ 当这些数据改变时，视图会进行重渲染。值得注意的是只有当实例被创建时就已经存在于 data 中的 属性才是响应式的。也就是说如果你添加一个新的属性，那么对这个新属性的改动将不会触发任何视图的更新。 ​ 如果你知道你会在晚些时候需要使用一个 property属性，但是一开始不需要使用它们，那么你可以设置一些初始值，这样后面就可以用到了。 Object.freeze()，这会阻止修改现有的 property，也意味着响应系统无法再追踪变化。 二、数据与方法​ 除了数据 的property，Vue 实例还提供了一些有用的实例 property 与方法。它们都有前缀 $，以便与用户定义的 property 区分开来。 注：这些的属性加不加$，都一样，只是多了一个写法，好区分开。 不要在选项 property 或回调上使用箭头函数，比如 created: () =&gt; console.log(this.a) 或 vm.$watch(&#39;a&#39;, newValue =&gt; this.myMethod())。 因为箭头函数并没有 this，this 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 Uncaught TypeError: Cannot read property of undefined 或 Uncaught TypeError: this.myMethod is not a function 之类的错误。 三、模板语法通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定： 双大括号会将数据解释为普通文本而输出，而非 HTML 代码。为了输出真正的 HTML，你需要使用 v-html指令: 注： 你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。请只对可信内容使用 HTML 插值，绝不要对用户提供的内容使用插值。 使用 JavaScript 表达式迄今为止，在我们的模板中，我们一直都只绑定简单的 property 键值。但实际上，对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。 ​ 这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含单个表达式，所以下面的例子都不会生效。 指令 v-if 指令将根据表达式 seen的值的真假来插入&#x2F;移除 元素。 ​ 2. 一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，v-bind 指令可以用于响应式地更新 HTML 的属性： 在这里 href 是参数，告知 v-bind 指令将该元素的 href 属性与表达式 url 的值绑定。 ​ v-bind缩写 v-on 指令，它用于监听 DOM 事件： 在这里参数是监听的事件名。 缩写 同样地，你可以使用动态参数为一个动态的事件名绑定处理函数： 在这个示例中，当 eventName 的值为 &quot;focus&quot; 时，v-on:[eventName] 将等价于 v-on:focus。 ​ 在 DOM 中使用模板时 (直接在一个 HTML 文件里撰写模板)，还需要避免使用大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写： ​ 缩写写法看起来可能与普通的 HTML 略有不同，但 : 与 @ 对于 attribute 名来说都是合法字符，在所有支持 Vue 的浏览器都能被正确地解析。而且，它们不会出现在最终渲染的标记中。缩写语法是完全可选的，但随着你更深入地了解它们的作用，你会庆幸拥有它们。 v-modelv-model中还可以使用一些修饰符来实现某些功能： v-model.lazy 只有在input输入框发生一个blur时才触发，也就是延迟同步到失去焦点时。 v-model.trim 将用户输入的前后的空格去掉。 v-model.number 将用户输入的字符串转换成number。 修饰符​ 修饰符 (modifier) 是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()： 四、计算属性和侦听器对于任何复杂逻辑，你都应当使用计算属性。 ​ vm.reversedMessage 的值始终取决于 vm.message 的值。 ​ Vue 知道 vm.reversedMessage 依赖于 vm.message，因此当 vm.message 发生改变时，所有依赖 vm.reversedMessage 的绑定也会更新。 ​ 我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。 这也同样意味着下面的计算属性将不再更新，因为 Date.now() 不是响应式依赖： 我们为什么需要缓存？​ 假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用method来替代。 五、侦听器当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。 watch能够监听数据的改变。监听之后会调用一个回调函数。 此回调函数的参数有两个： 更新后的值（新值） 更新前的值（旧值） 六、Vue操作数组​ Vue 提供一组观察数组的变异方法（就是这些方法会改变原始数组，所以才会被Vue检测到），使用它们就可以触发视图更新。 这些方法有7个：push()、pop()、shift()、unshift()、splice()、sort()、reverse() 七、过滤器过滤器是对即将显示的数据做进一步的筛选处理，然后进行显示，值得注意的是过滤器并没有改变原来的数据，只是在原数据的基础上产生新的数据。 过滤器分全局过滤器和本地过滤器（局部过滤器）。 全局过滤器下面定义一个全局过滤器，用于在数据前加上大写的VUE。需要注意的是，全局过滤器定义必须始终位于Vue实例之上，否则会报错。 注意： Vue.filter() 后有两个参数：过滤器名，过滤器处理函数。 过滤器处理函数也有一个参数：要过滤的数据。 本地过滤器本地过滤器存储在vue组件中，作为filters属性中的函数，我们可以注册多个过滤器存储在其中。 "},{"title":"SweetAlert2实践","date":"2022-05-08T08:46:11.000Z","url":"/2022/05/08/SweetAlert2%E5%AE%9E%E8%B7%B5/","categories":[["前端框架","/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"],["SweetAlert2","/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/SweetAlert2/"]],"content":"SweetAlert2 实践 一、多重弹窗（重复确认） ( focusCancel: true自动聚焦取消键， 按钮还是左边取消键看得舒服一点 强迫症reverseButtons: true ) 测试截图： 二、在SweetAlert2中添加html标签内容SweetAlert2测试如图： 我拿bootstrap的模态框对比： 虽然两个都好看，但还是觉得bootstrap的模态框更好用，写起来更方便。 话不多说了 先放上sweetAlert的测试代码： 注：这里的msg数据为空，仅仅是测试，数据获取可通过用ajax返回后台数据即可。 三、与Ajax搭配使用下面展示的测试登录案例： 运行截图： 只完成登录成功显示的部分， 后台返回的msg，如密码错误等信息显示还未显示，时间充裕的话再补上吧 ! "},{"title":"sweetAlert2","date":"2022-05-08T08:05:27.000Z","url":"/2022/05/08/sweetAlert2/","categories":[["前端框架","/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"],["SweetAlert2","/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/SweetAlert2/"]],"content":"官方文档： 一、简介SweetAlert2用于替代浏览器默认的弹出对话框，是一个美观，响应，可定制，可访问替代JAVASCRIPT的弹出框。传统的弹窗相比之下实属不好看，而SweetAlert2能帮我们解决这个问题。 二、安装 三、 快速入门 四、常用配置 title：模态的标题 text：模态的描述。如果同时提供“text”和“html”参数，则将使用“text”。 type：模态的类型。SweetAlert2附带5种内置类型，可显示相应的图标动画：warning, error, success, info, 和 question。它可以放在键“type”下的数组中，也可以作为函数的第三个参数传递。 footer: 莫代尔的页脚。可以是纯文本或HTML。 toast: 是否应将警报视为Toast通知。此选项通常与position参数和计时器耦合。Toast永远不会自动聚焦。( 如上示例) width：模态窗口宽度，包括填充 (box-sizing: border-box).可以是px 或 %. 默认宽度为 32rem. padding：模态窗口填充。默认填充为 1.25rem. background：模态窗口背景（CSS背景属性）。默认背景为**’#fff’**. position：模态窗口位置可以是**’top’**, ‘top-start’, ‘top-end’, ‘center’, ‘center-start’, ‘center-end’, ‘bottom’, ‘bottom-start’, 或 ‘bottom-end’. 默认值是 *’center’*。 timer：自动关闭模态的计时器。以ms（毫秒）为单位。 animation：默认值为true。如果设置为false，则将禁用模态CSS动画。 preConfirm：在确认之前执行的功能可以是异步（Promise-returning）或同步。 false以防止弹出窗口关闭 别的传递该值作为result.value 的 Swal.fire() undefined 保留默认的 result.value 按键 allowEnterKey：默认值为true。如果设置为false，则用户无法通过按Enter键或空格键确认模态，除非他们手动对焦确认按钮。您还可以传递返回布尔值的自定义函数。 allowEscapeKey：默认为true。如果设置为false，则用户无法通过按键关闭模式Esc。您还可以传递返回布尔值的自定义函数，例如，如果要禁用Esc模式加载状态的键。 allowOutsideClick：默认值为true。如果设置为false，则用户无法通过单击外部来解除模态。 showConfirmButton：默认值为true。如果设置为false，则不会显示“确认”按钮。当您使用自定义HTML描述时，它会很有用。 showCancelButton：默认值为false。如果设置为true，将显示“取消”按钮，用户可以单击该按钮以关闭模式。 confirmButtonText：使用此选项可更改“确认”按钮上的文本。 cancelButtonText：使用此选项可更改”Cancel”按钮上的文本。 confirmButtonColor： 使用此选项可更改”Confirm”按钮的背景颜色。默认颜色为**#3085d6**。（其它按键类似） 我们可以通过使用**Swal.mixin({ …options })**创建自己的Swal来轻松地重用配置 五、弹出的五种类型： 六、方法 方法 描述 Swal.isVisible() 确定是否显示模态。 Swal.mixin({ …options }) 返回包含params作为默认值的Swal的扩展版本。用于重用Swal配置。 Swal.update({ …options }) 更新弹出选项。 Swal.close() 以编程方式关闭当前打开的SweetAlert2模式，Swal.fire（）返回的Promise 将使用空对象{}解析 Swal.getContainer() 获取包含背景的弹出容器。 Swal.getHeader() 获取模态标题。标题包含进度步骤，图标，图像，标题和关闭按钮。 Swal.getTitle() 获得模态标题。 Swal.getCloseButton() 获取关闭按钮。 Swal.getContent() 获取模态内容。 Swal.getImage() 获取image. Swal.getActions() 获取动作块（按钮容器）。 Swal.getFooter() 得到模态页脚。 Swal.getFocusableElements() 获取弹出窗口中的所有可聚焦元素。 Swal.getConfirmButton() 获取 “Confirm” 按钮. Swal.getCancelButton() 获取 “Cancel” 按钮. Swal.enableButtons() 启用 “Confirm” 和 “Cancel” 按钮. Swal.disableButtons() 禁用 “Confirm” 和 “Cancel” 按钮. Swal.enableConfirmButton() 已弃用并将在下一个主要版本中删除，请改用Swal.getConfirmButton(). 仅启用”Confirm”按键 Swal.disableConfirmButton() 已弃用并将在下一个主要版本中删除，请改用Swal.getConfirmButton() . 仅禁用”Confirm”按键 Swal.showLoading() or Swal.enableLoading() 禁用按钮和显示加载程序。这对AJAX请求很有用。 Swal.hideLoading() or Swal.disableLoading() 启用按钮并隐藏加载程序。 Swal.isLoading() 确定模态是否处于加载状态。相关方法：Swal.showLoading() 和 Swal.hideLoading() Swal.getTimerLeft() 返回设置 timer 参数时剩余的时间。 Swal.stopTimer() 如果设置了timer参数，则停止计时器。返回剩余的时间 Swal.resumeTimer() 恢复先前停止的timer。返回剩余的时间 Swal.toggleTimer() 在已停止和正在运行之间切换timer状态。返回剩余的时间 Swal.isTimerRunning() 返回timer的状态：如果正在运行，则为true;如果已暂停，则为false Swal.increaseTimer(n) 增加timer by n 毫秒。返回剩余的时间 Swal.clickConfirm() 以编程方式单击”Confirm”按钮 Swal.clickCancel() 以编程方式单击”Cancel”按钮 Swal.getInput() 获取输入DOM节点，此方法适用于输入参数. Swal.disableInput() 禁用输入。禁用的输入元素不可用且不可单击。 Swal.enableInput() 启用输入。 Swal.showValidationMessage(error) 显示验证消息DOM节点。 Swal.resetValidationMessage() 隐藏验证消息DOM节点。 Swal.getValidationMessage() 获取验证消息DOM节点。 Swal.queue([Array]) 提供SweetAlert2参数数组以显示多个模态，一个模态接一个。请参阅用法事例 Swal.getQueueStep() 获取队列中当前模态的索引。如果没有活动队列，则返回 null Swal.insertQueueStep() 将模态插入队列，您可以使用第二个参数指定模态定位。默认情况下，模式将添加到队列的末尾。 Swal.deleteQueueStep(index) 从队列中删除index处的模态。 Swal.getProgressSteps() 进步步骤吸气剂。 Swal.setProgressSteps([]) 进度步骤设定器。 Swal.showProgressSteps() 显示进度步骤。 Swal.hideProgressSteps() 隐藏进度步骤。 Swal.isValidParameter(param) 确定参数名称是否有效。 Swal.isUpdatableParameter(param) 确定参数名称是否对Swal.update()方法有效。 今天只有一天周末时间不用补课，再来复习复习这个前端框架！"},{"title":"ES6.0学习","date":"2022-05-06T06:50:26.000Z","url":"/2022/05/06/ES6-0%E5%AD%A6%E4%B9%A0/","tags":[["es6","/tags/es6/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"],["es6","/categories/%E5%89%8D%E7%AB%AF/es6/"]],"content":"一、简介ES6， 全称 ECMAScript 6.0 ，是 JavaScript 的下一个版本标准，2015.06 发版。 ES6 主要是为了解决 ES5 的先天不足，比如 JavaScript 里并没有类的概念。 二、ES6 的目标与愿景 成为更好编写的开发语言有以下目标。 适应更复杂的应用；实现代码库之间的共享；不断迭代维护新版本。 三、ES6 环境目前各大浏览器基本上都支持 ES6 的新特性，其中 Chrome 和 Firefox 浏览器对 ES6 新特性最友好，IE7~11 基本不支持 ES6。 四、ES6基础４.1 let命令ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 块级作用域在一些情况下，可以避免内层变量覆盖外层变量。 Let不存在变量提升 控制台的输出结果： ​ 上面代码中，变量t1用var命令声明，会发生变量提升，即脚本开始运行时，变量t1已经存在了，但是没有值，所以会输出undefined。 ​ 变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。 因此，使用let声明变量，极大的消除了代码的潜在bug的隐患。 Let暂时性死区: 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。 4.2 const 命令const声明一个只读的常量。一旦声明，常量的值就不能改变 上面代码表明改变常量的值会报TypeError: Assignment to constant variable的错。 4.3 模板字符串 注意：ES6模板字符串中必须要使用反引号。 4.4 rest参数ES6 引入 rest 参数（形式为“…变量名”），用于获取函数的多余参数。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 上面代码的add函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。rest 参数中的变量代表一个数组，所以数组特有的方法都可以用于这个变量。 4.5 箭头函数ES6允许使用“箭头”（&#x3D;&gt;）定义函数： 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分 如果只有一个参数，那么圆括号就可以省略了 如何函数体中的代码只有一句，那么大括号可以省略 如果函数体中的代码只有一个return语句，那么return关键词也必须省略 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。 箭头函数有几个使用注意点。 函数体内的this对象。函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。或者说：箭头函数当方法使用时没有定义this绑定，而是捕获所在上下文的 this ，作为自己的 this 。 注意： 箭头函数的this永远指向其上下文的 this。 普通函数的this指向调用它的那个对象。 不可以当作构造函数。也就是说，不可以使用new命令，否则会抛出一个错误。 不可以使用arguments对象。该对象在函数体内不存在。如果要用，可以用Rest参数代替。 箭头函数的一个用处是简化回调函数 简写简单说就是省略掉function，直接写（），或者不写；大括号可变箭头 &#x3D;&gt; , 函数体只有一条可以直接写，有return就省略 rest参数与箭头函数结合 五、ES6 类（Class）​ ES6提供了更接近面向对象（注意：javascript本质上是基于对象的语言）语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。 ​ 新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。 上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。也就是说，ES5的构造函数Point，对应ES6的Point类的构造方法。 Point类除了构造方法，还定义了一个toString方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。 注意：生成类的实例对象的写法，要使用new命令。如果忘记加上new，像ES5函数那样调用Class，将会报错。 ​ ……….. 六、ES6模块化编程6.1 ES6模块化实现​ 模块功能主要由两个命令构成：export和import。 ​ export命令用于规定模块的对外接口 。 ​ import命令用于输入其他模块提供的功能。 1. export 命令 在export命令后面，使用大括号指定所要输出的一组变量。 export命令除了输出变量，还可以输出函数、类（class）。 2. import命令 使用export命令定义模块对外接口后，其他 JS 文件就可以通过import命令加载这个模块。 ​ 上面代码的import命令，用于加载module1.js文件，并从中输入变量。import命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（ module1.js）对外接口的名称相同。 import命令可以使用as关键字，将输入的变量重命名。 import命令具有提升效果，会提升到整个模块的头部，首先执行 上面的代码不会报错，因为import的执行早于foo的调用。这种行为的本质是，import命令是编译阶段执行的，在代码运行之前。 import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。 如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次 import语句是 Singleton 模式 上面代码中，虽然foo和bar在两个语句中加载，但是它们对应的是同一个my_module实例。也就是说，import语句是 Singleton 模式。 3. 模块的整体加载​ 除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。 "},{"title":"mybatis入门","date":"2022-05-06T06:38:49.000Z","url":"/2022/05/06/mybatis%E5%85%A5%E9%97%A8/","tags":[["mybatis","/tags/mybatis/"]],"categories":[["mybatis","/categories/mybatis/"]],"content":"注：基于Mysql8版本 目录结构 jdbc.properties log4j日志配置 log4j.properties 注：以上是控制台输出日志，注释的为文件日志 mybatis-config.xml mybatis配置文件 工具类 MybatisUtils.java 创建实体类 Book.java 数据库表 book_info 插入数据sql语句： sql语句展开 创建接口 xml方式实现：BookDao.xml映射文件（只示例了其中一个方法， 另一个使用了注解) 测试： 运行结果： 注解方式实现：创建实体类 Emp.java 接口上通过注解编写sql 测试 测试结果： "},{"title":"数据层层获取数据id执行增删查改（踩坑）","date":"2022-05-05T16:55:22.000Z","url":"/2022/05/06/controller%E5%B1%82%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AEid%E6%89%A7%E8%A1%8C%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9%E8%B8%A9%E5%9D%91/","tags":[["javaweb","/tags/javaweb/"]],"categories":[["javaweb","/categories/javaweb/"]],"content":"去掉获取的字符串参数的两侧空白字符或其它字符，再进行整型转化即可成功！！注：单纯的写Integer.parseInt(request.getParameter(“id”)容易出错，总会面对String型数据转化 int 类型失败的问题 “ int id &#x3D; Integer.parseInt(request.getParameter(id”).trim()); "},{"title":"json与字符串之间的转换","date":"2022-05-05T16:39:38.000Z","url":"/2022/05/06/json%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/","categories":[["javaweb","/categories/javaweb/"]],"content":"javaScript中内置了一个JSON对象，可以用来进行json与字符串之间的转换 json转换成字符串：使用JSON.stringify() 字符串转换成json：使用JSON.parse() java对象转化为json格式字符串数据返回到前端页面JsonModel.java JsonUtil.java controller层返回json数据 —— servlet测试 "},{"title":"jdbc - 可变参数的通用增删查改","date":"2022-05-05T16:18:52.000Z","url":"/2022/05/06/jdbc-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%9A%84%E9%80%9A%E7%94%A8%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9/","tags":[["javaweb","/tags/javaweb/"]],"categories":[["javaweb","/categories/javaweb/"]],"content":"通用的查询修改方法，减少写重复的代码"},{"title":"javaweb-登录验证功能","date":"2022-05-02T10:27:54.000Z","url":"/2022/05/02/javaweb-%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81%E5%8A%9F%E8%83%BD/","categories":[["javaweb","/categories/javaweb/"]],"content":"学习记录 MySQL数据库表里，我将管理员跟用户都放一张表里，通过表里的status字段进行权限验证，为1是管理员，0为用户（int）。 登录处理LoginController.jsp： 下拉列表（后台获取name里的参数）： 获取下拉列表的name参数 控制层可以根据下拉列表进行登录验证（选择登录后台或者前台） "},{"title":"bootstrapTable+模态框+显示表格数据的问题","date":"2022-05-02T09:10:03.000Z","url":"/2022/05/02/bootstrapTable-%E6%A8%A1%E6%80%81%E6%A1%86-%E6%98%BE%E7%A4%BA%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE%E7%9A%84%E9%97%AE%E9%A2%98/","tags":[["bootstrap-table","/tags/bootstrap-table/"]],"categories":[["前端框架","/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"],["bootstrap-table","/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/bootstrap-table/"]],"content":"在线链接： 在我们的数据表格里每行对应的编辑按钮，当我们点击后，会弹出对应行的数据，并可以进行修改数据并提交。 测试结果如下： 对应代码： &#x2F;&#x2F; getData方法获取全部页面数据后，将data转为json对象，使用index当前行号作为下标获取对应数据 data_json的结果类型——每一行数据对应一个object： data_json : [object Object],[object Object],[object Object],[object Object],[object Object],[object Object] var data &#x3D; JSON.stringify($(“#exampleTableEvents”).bootstrapTable(‘getData’)) ： 转化为json格式数据 &#x2F;&#x2F; 删除用户 编辑用户信息 —— 模态框动态显示表格数据: bootstrap-table（html骨架）: "},{"title":"fastjson导包错误500","date":"2022-05-02T07:29:51.000Z","url":"/2022/05/02/fastjson%E5%AF%BC%E5%8C%85%E9%94%99%E8%AF%AF500/","tags":[["500","/tags/500/"]],"categories":[["报错信息合集","/categories/%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF%E5%90%88%E9%9B%86/"]],"content":"报错信息：今天使用fastjson 的TypeReference 进行反序列化的时候出现了这个错误,说是找不到类,但是实际上我是添加了相关jar包的。 解决方法就是, 将你的jar包放入项目自带的lib文件夹里就OK了 HTTP状态 500 - 内部服务器错误 类型 异常报告 消息 Servlet执行抛出一个异常 描述 服务器遇到一个意外的情况，阻止它完成请求。 例外情况 根本原因。 ):注意 主要问题的全部 stack 信息可以在 server logs 里查看 Apache Tomcat&#x2F;9.0.55"},{"title":"bootstrap-table使用","date":"2022-04-28T12:14:30.000Z","url":"/2022/04/28/bootstrap-table%E4%BD%BF%E7%94%A8/","tags":[["bootstrap-table","/tags/bootstrap-table/"]],"categories":[["前端框架","/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"],["bootstrap-table","/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/bootstrap-table/"]],"content":"在线链接 同时，还需要用户bootstrap的css和js文件，否则 bootstrap-table的按钮显示不全（bootstrap4版本不兼容） 点击列名获取一整行的数据换句话说就是根据唯一的id或者其他属性，获取该行的数据。 首先通过表格的id绑定一个唯一的列字段属性名（不是title后面的，是field后面的属性名）。这里我们指定id为唯一列字段，因为这个id是数据库中的自增[主键]，不会重复。 columns属性是设置显示数据字段内容，其中field属性值需要和实体类对应。 注：formaterProcess(value, rows) ： 其中参数value表示field对应实体类中的值，row为当前行的数据，（如果有第三个参数，则为当前行的索引）。 测试结果： "},{"title":"springmvc-异常处理（待更新）","date":"2022-04-26T10:59:07.000Z","url":"/2022/04/26/springmvc-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","tags":[["Spring MVC","/tags/Spring-MVC/"]],"categories":[["Spring","/categories/Spring/"],["Spring MVC学习","/categories/Spring/Spring-MVC%E5%AD%A6%E4%B9%A0/"]]},{"title":"springmvc7 - JSON","date":"2022-04-26T10:29:58.000Z","url":"/2022/04/26/springmvc7-JSON/","tags":[["springboot2","/tags/springboot2/"]],"categories":[["springboot2","/categories/springboot2/"],["springboot2入门","/categories/springboot2/springboot2%E5%85%A5%E9%97%A8/"]],"content":"一、各种Date之间的转换方法实体类日期字段： new Date() 的结果： birth： “2022-04-26T11:00:29.961+00:00” 问题： 这个时间格式并不是我想要的，想调整为yyyy-MM-dd HH:mm:ss这种常见格式返回到前端。 解决方法： 如下的各种Date之间的转换方法 这里我选用： 输出结果： birth： “2022-04-26 20:13:40” 即可成功解决！ 注： mysql数据库时间用datetime类型可以精确到秒， date类型只到年月日。 二、注解解析1. @JsonFormat： 用法 ：为在属性值上 @JsonFormat(pattern&#x3D;”yyyy-MM-dd”,timezone&#x3D;”GMT+8”)，如果直接使用 @JsonFormat(pattern&#x3D;”yyyy-MM-dd”)就会出现相差8个小时的情况，因为我们是东八区（北京时间）。所以我们在格式化的时候要指定时区（timezone ） 2.@JsonIgnore： 此注解用于属性或者方法上（最好是属性上），用来完全忽略被注解的字段和方法对应的属性，即便这个字段或方法可以被自动检测到或者还有其他的注解，一般标记在属性或者方法上，返回的json数据即不包含该属性。 3.@JsonProperty ： 此注解用于属性上，作用是把该属性的名称序列化为另外一个名称。 对属性名称重命名，比如在很多场景下Java对象的属性是按照规范的驼峰书写，但在数据库设计时使用的是下划线连接方式，此处在进行映射的时候就可以使用该注解。 如把实体类的trueName属性序列化为name，@JsonProperty(“name”)。 感觉这个注解的作用是： 前端传参数过来的时候，使用这个注解，可以获取到前端与注解中同名的属性 后端处理好结果后，返回给前端的属性名也不以实体类属性名为准，而以注解中的属性名为准 "},{"title":"Swagger2学习","date":"2022-04-25T11:42:35.000Z","url":"/2022/04/25/Swagger2%E5%AD%A6%E4%B9%A0/","tags":[["springboot2","/tags/springboot2/"]],"categories":[["springboot2","/categories/springboot2/"],["springboot2入门","/categories/springboot2/springboot2%E5%85%A5%E9%97%A8/"]],"content":"springboot 2.6 版本以上的要在配置文件(yml&#x2F; properties)里添加下面的配置信息 一、常用注解Swagger的所有注解定义在io.swagger.annotations包下 下面列一些经常用到的，未列举出来的可以另行查阅说明： Swagger注解 简单说明 @Api(tags &#x3D; “xxx模块说明”) 作用在模块类上 @ApiOperation(“xxx接口说明”) 作用在接口方法上 @ApiModel(“xxxPOJO说明”) 作用在模型类上：如VO、BO @ApiModelProperty(value &#x3D; “xxx属性说明”,hidden &#x3D; true) 作用在类方法和属性上，hidden设置为true可以隐藏该属性 @ApiParam(“xxx参数说明”) 作用在参数、方法和字段上，类似@ApiModelProperty 二、 依赖 三、 配置类SwaggerConfig 四、 实体配置1、新建一个实体类： 2 、只要这个实体在请求接口的返回值上（即使是泛型），都能映射到实体项中： 注：并不是因为@ApiModel这个注解让实体显示在这里了，而是只要出现在接口方法的返回值上的实体都会显示在这里，而@ApiModel和@ApiModelProperty这两个注解只是为实体添加注释的。 @ApiModel为类添加注释 @ApiModelProperty为类属性添加注释 我们也可以给请求的接口配置一些注释 这样的话，可以给一些比较难理解的属性或者接口，增加一些配置信息，让人更容易阅读！ 相较于传统的Postman或Curl方式测试接口，使用swagger简直就是傻瓜式操作，不需要额外说明文档(写得好本身就是文档)而且更不容易出错，只需要录入数据然后点击Execute，如果再配合自动化框架，可以说基本就不需要人为操作了。 缺点：在正式环境要记得关闭Swagger，一来出于安全考虑二来也可以节省运行时内存。 重启项目，访问测试  看下效果； 五、拓展：其他皮肤我们可以导入不同的包实现不同的皮肤定义： 1、默认的 访问  2、bootstrap-ui 访问  3、Layui-ui 访问  4、mg-ui 访问  "},{"title":"AOP实现操作日志记录","date":"2022-04-24T13:21:50.000Z","url":"/2022/04/24/AOP%E5%AE%9E%E7%8E%B0%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/","tags":[["springboot2","/tags/springboot2/"]],"categories":[["springboot2","/categories/springboot2/"],["springboot2入门","/categories/springboot2/springboot2%E5%85%A5%E9%97%A8/"]]},{"title":"Slf4j+logback日志使用（未完待续）","date":"2022-04-24T12:32:22.000Z","url":"/2022/04/24/springboot%E6%97%A5%E5%BF%97%E4%BD%BF%E7%94%A8/","tags":[["springboot2","/tags/springboot2/"]],"categories":[["springboot2","/categories/springboot2/"],["springboot2入门","/categories/springboot2/springboot2%E5%85%A5%E9%97%A8/"]],"content":"​ 日志，通常不会在需求阶段作为一个功能单独提出来，也不会在产品方案中看到它的细节。但是，这丝毫不影响它在任何一个系统中的重要的地位。 ​ 为了保证服务的高可用，发现问题一定要即使，解决问题一定要迅速，所以生产环境一旦出现问题，预警系统就会通过邮件、短信甚至电话的方式实施多维轰炸模式，确保相关负责人不错过每一个可能的bug。 ​ 预警系统判断疑似bug大部分源于日志。比如某个微服务接口由于各种原因导致频繁调用出错，此时调用端会捕获这样的异常并打印ERROR级别的日志，当该错误日志达到一定次数出现的时候，就会触发报警。 日志Log默认格式Spring Boot 的默认日志输出类似于以下示例(springboot运行时控制台的输出)： 详细介绍： 日期和时间：毫秒精度，易于排序。 日志级别：ERROR、WARN、INFO、DEBUG 或 TRACE。 进程标识（动态分配）。 A — 分隔符来区分实际日志消息的开始。 线程名称：括在方括号中（可能会被截断以用于控制台输出）。 记录器名称：这通常是源类名称（通常缩写）。 日志消息。 日志级别大小：TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL ，且级别是逐渐提供，如果日志级别设置为INFO，则意味TRACE和DEBUG级别的日志都看不到。如果这里设置为WARN，INFO级别的日志都不显示。 Spring Boot默认日志系统Spring Boot默认使用LogBack日志系统，如果不需要更改为其他日志系统如Log4j2等，则无需多余的配置，LogBack默认将日志打印到控制台上。 如何将日志信息存储到文件在本机环境，我们习惯在控制台看日志，但是线上我们还是要通过将日志信息保存到日志文件中，查询日志文件即可。 摘抄记录："},{"title":"springboot热部署","date":"2022-04-24T11:47:19.000Z","url":"/2022/04/24/springboot%E7%83%AD%E9%83%A8%E7%BD%B2/","tags":[["springboot2","/tags/springboot2/"]],"categories":[["springboot2","/categories/springboot2/"],["springboot2入门","/categories/springboot2/springboot2%E5%85%A5%E9%97%A8/"]],"content":"第一步：导入pom依赖 第二步： 在IDEA中的配置、 ​ 较新的版本是在setting -》 Advanced Settings -》 勾选compiler类型的框中的选项 完成这两步之后即可完成热部署，在类文件修改代码后，可以花几秒的时间摸鱼再刷新页面，即可出现新数据。"},{"title":"private static final long serialVersionUID=1L什么意思","date":"2022-04-24T10:12:42.000Z","url":"/2022/04/24/private-static-final-long-serialVersionUID-1L%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/","tags":[["springboot2","/tags/springboot2/"]],"categories":[["springboot2","/categories/springboot2/"],["springboot2入门","/categories/springboot2/springboot2%E5%85%A5%E9%97%A8/"]],"content":"serialVersionUID作用： 相当于java类的身份证。主要用于版本控制。 serialVersionUID作用是序列化时保持版本的兼容性，即在版本升级时反序列化仍保持对象的唯一性。 ​ 序列化时为了保持版本的兼容性，即在版本升级时反序列化仍保持对象的唯一性。 有两种生成方式： 一个是默认的1L，比如：private static final long serialVersionUID &#x3D; 1L; 一个是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段，比如： private static final long serialVersionUID &#x3D; xxxxL; ​ serialVersionUID是可序列化类的一个版本标识，在反序列化的时候使用这个标识的值来判断序列化和反序列化的对象类型是否一致。Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常（InvalidClassException）。当你一个类实现了Serializable接口，如果没有定义serialVersionUID，Eclipse会提供这个提示功能告诉你去定义之。 总结（重点思考）工作中我们经常在进行持久化操作和返回数据时都会使用到javabean来统一封装参数，方便操作，一般我们也都会实现Serializable接口，那么问题来了，首先：为什么要进行序列化；其次：每个实体bean都必须实现serializabel接口吗？最后：我做一些项目的时候，没有实现序列化，同样没什么影响，到底什么时候应该进行序列化操作呢？ 网上找了很多资料，但是感觉大都没有说的很清楚，所以结合自己的理解做一下总结。 首先第一个问题，实现序列化的两个原因：1、将对象的状态保存在存储媒体中以便可以在以后重新创建出完全相同的副本；2、按值将对象从一个应用程序域发送至另一个应用程序域。实现serializabel接口的作用是就是可以把对象存到字节流，然后可以恢复，所以你想如果你的对象没实现序列化怎么才能进行持久化和网络传输呢，要持久化和网络传输就得转为字节流，所以在分布式应用中及设计数据持久化的场景中，你就得实现序列化。 第二个问题，是不是每个实体bean都要实现序列化，答案其实还要回归到第一个问题，那就是你的bean是否需要持久化存储媒体中以及是否需要传输给另一个应用，没有的话就不需要，例如我们利用fastjson将实体类转化成json字符串时，并不涉及到转化为字节流，所以其实跟序列化没有关系。 第三个问题，有的时候并没有实现序列化，依然可以持久化到数据库。这个其实我们可以看看实体类中常用的数据类型，例如Date、String等等，它们已经实现了序列化，而一些基本类型，数据库里面有与之对应的数据结构，从我们的类声明来看，我们没有实现serializabel接口，其实是在声明的各个不同变量的时候，由具体的数据类型帮助我们实现了序列化操作。 另外需要注意的是，在NoSql数据库中，并没有与我们java基本类型对应的数据结构，所以在往nosql数据库中存储时，我们就必须将对象进行序列化，同时在网络传输中我们要注意到两个应用中javabean的serialVersionUID要保持一致，不然就不能正常的进行反序列化。 "},{"title":"Valid 注解数据校验（JSR - 303）（未完待续）","date":"2022-04-24T09:29:13.000Z","url":"/2022/04/24/%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/","tags":[["springboot2","/tags/springboot2/"]],"categories":[["springboot2","/categories/springboot2/"],["springboot2入门","/categories/springboot2/springboot2%E5%85%A5%E9%97%A8/"]],"content":"一、JSR - 303 ​ JSR 是 Java Specification Requests 的缩写，即 Java 规范提案。 存在各种各样的 JSR，简单的理解为 JSR 是一种 Java 标准。 JSR 303 就是数据检验的一个标准（Bean Validation (JSR 303)）。 二、为什么使用JSR-303​ 处理一段业务逻辑，首先要确保数据输入的正确性，所以需要先对数据进行检查，保证数据在语义上的正确性，再根据数据进行下一步的处理。 前端可以通过 js 程序校验数据是否合法，后端同样也需要进行校验。而后端最简单的实现就是直接在业务方法中对数据进行处理，但是不同的业务方法可能会出现同样的校验操作，这样就出现了数据的冗余。为了解决这个情况，JSR 303 出现了。 JSR-303 使用 Bean Validation，即在 Bean 上添加相应的注解，去实现数据校验。这样在执行业务方法前，都会根据注解对数据进行校验，从而减少自定义的校验逻辑，减少代码冗余。 ​ (参考：) 导入依赖： "},{"title":"注解@ConfigurationProperties使用方法","date":"2022-04-23T15:51:14.000Z","url":"/2022/04/23/%E6%B3%A8%E8%A7%A3-ConfigurationProperties%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","tags":[["springboot2","/tags/springboot2/"]],"categories":[["springboot2","/categories/springboot2/"],["springboot2入门","/categories/springboot2/springboot2%E5%85%A5%E9%97%A8/"]],"content":"注意：根据 Spring Boot 松散绑定，类的属性名称必须与外部属性的名称匹配 以上四种命名可以自动绑定bean属性（properties配置文件也可用该注解） 激活 @ConfigurationProperties​ 我们除了在实体类上标注注解@ConfigurationProperties，还需要让spring容器知道它的存在，以便将其加载到应用程序上下文中。 ​ 所以，我们可以通过添加 @Component 注解让 Component Scan 扫描到 ​ ${user.userName}只支持属性的调用，不支持运算 测试yml配置文件： Person实体类： Address实体类： 用法: 输出 JSON格式： 总结 @ConfigurationProperties 和 @value 有着相同的功能,但是 @ConfigurationProperties的写法更为方便 @ConfigurationProperties 的 POJO类的命名比较严格,因为它必须和prefix的后缀名要一致, 不然值会绑定不上, 特殊的后缀名是“driver-class-name”这种带横杠的情况,在POJO里面的命名规则是 下划线转驼峰 就可以绑定成功，所以就是 “driverClassName” "},{"title":"springboot的相关注解","date":"2022-04-21T14:29:45.000Z","url":"/2022/04/21/springboot%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/","tags":[["springboot2","/tags/springboot2/"]],"categories":[["springboot2","/categories/springboot2/"],["springboot2入门","/categories/springboot2/springboot2%E5%85%A5%E9%97%A8/"]],"content":"一、 Java注解的介绍​ JRE 的库包 java.lang.annotation 中代码包括注释相关的接口、类等内容。接口 java.lang.annotation 是所有自定义注解自动继承的接口，不需要定义时指定。 ​ 注解是一系列元数据，它利用元数据来解释、说明程序代码（被注解的对象）。 二、Java的元注解元注解是加到注解上的注解，它的目的是解释、说明其他普通注解。 ​ 元注解有@Retention、@Taget、@Inherited、@Documented、@intertface五种。 2.1 @Taget​ @Taget该注解的作用是告诉 Java 将自定义的注解用于什么地方，比如类、方法、构造器、变量上等，它的值是一个枚举类型，有如下属性值。 ElementType.CONSTRUCTOR：用于描述构造器。 ElementType.FIELD：用于描述成员变量、对象、属性（ 包括enum实例 ）。 ElementType.LOCAL_VARIABLE：用于描述局部变量。 ElementType.METHOD：用于描述方法。 ElementType.PACKAGE：用于描述包。 ElementType.PARAMETER：用于描述参数。 ElementType.TYPE：用于描述类、接口（ 包括注解类型 ）或 enum 声明。 2.2 @Retention该注解用于说明自定义注解的生命周期，在注解中有三个生命周期。 RetentionPolicy.RUNTIME：始终不会丢弃， 运行期也保留读注解，可以使用反射机制读取该注解的信息。 自定义的注解通常使用这种方式。 RetentionPolicy.CLASS：类加载时丢弃，默认使用这种方式。 RetentionPolicy.SOURCE：编译阶段丢弃，自定义注解在编译结束之后就不再有意义，所以它们不会写入字节码。@Overide、@SuppressWarnings 都属于这类注解。 2.3 @Inherited​ 被@Inherited注解过的注解作用于父类后，子类会自动继承父类的注解。 2.4 @Documented该注解表示是否将注解信息添加在 Java 文档中。 2.5 @intertface该注解用来声明一个注解， 其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（ 返回值类型只能是基本类型、Class、String、enum ）。可以通过 default 来声明参数的默认值。 定义注解格式的代码：public @interface 注解名 {定义体} 三、常用的注解​ @RequestMapping：为类或者方法指定一个映射路径，可以通过指定的路径来访问对应的类或者方法。 ​ @PathVariable： 主要用来获取单一的URI参数。 ​ @RequestBody：把请求报文中的正文自动转换成绑定给方法参数的变量字符串。（JSON格式返回数据） ​ @Param： 表示对参数的解释，一般写在注释里。 ​ @JoinTable：表示Java类和数据库表的映射关系，也可以标识列的映射，主键的映射等。 ​ @Transational： Spring事务管理的注解。被它标注的方法或类自动被注册成事务，接受spring容器的管理。 ​ @Syschronized: 表示实现Java同步机制，用它作注解相当于加同步锁。 ​ @Cacheable： 表明一个方法的返回值应该被缓存，注解@CacheFlush声明一个方法是清空缓存的触发器，这两个注解要配合缓存器使用。 ​ @Conditional：根据满足某一特定条件创建一个特定的bean。 ​ @ModelAttribute：声明在属性上，表示该属性来源于model里queryBean，并保存到model里。该注解声明在方法上，表示该方法的返回值被保存到model里。 四、JPA注解​ @Entity: 表明被标注的对象是个实体类 ​ @Table(name&#x3D;””) : 指出实体对应的表名； ​ 这两个注解一般一起使用。但是如果表名和实体类名相同，则@Table可以省略。 ​ 进行开发项目时，经常会用到将实体类映射到数据库表的操作。有时需要映射的几个实体类有共同的属性，这时可以把这些属性抽象成一个父类，然后各个实体类继承这个父类。可以使用@MappedSuperclass注解标注父类，它不会映射到数据库表，但子类在映射时会自动扫描父类的映射属性，并将这些属性添加到子类对应的数据库表中。使用@MappedSuperclass注解后不能再有@Entity或者@Table注解。 ​ @Column：标识实体类中属性与数据表中的字段的对应关系。如果注解@Column的字段名与列名相同，则可以省略。 该注解有10个属性，且均为可选属性。内容略。。。 ​ @Id: 用于声明一个实体类的属性映射为数据库的主键列。 ​ @JoinColumn(name&#x3D;”loginId”)：表示一张表有指向另一个表的外键。 五、异常处理​ @ControllerAdvice包含@Component，可以被扫描到，统一异常处理。 ​ @ExceptionHandler(Exception.class)：用在方法上面表示遇到这个异常就执行所标注的方法"},{"title":"Springboot简介","date":"2022-04-21T13:14:25.000Z","url":"/2022/04/21/Springboot%E5%85%A5%E9%97%A8/","tags":[["springboot2","/tags/springboot2/"]],"categories":[["springboot2","/categories/springboot2/"],["springboot2入门","/categories/springboot2/springboot2%E5%85%A5%E9%97%A8/"]],"content":"使用2.0.0以上版本的springboot需要安装jdk1.8以上的版本！！ 一、springboot2的核心模块​ springboot中提供了许多的starter模块，为开发者提供了许多“一站式”服务。通过在项目添加对应框架的starter依赖，可以免去到处寻找依赖包的烦恼。只要加一个依赖项目就可以运行，这就是starter的作用。Springboot官方提供的starter模块，一般命名“spring-boot-starter-*”，其中 “ * ”代表要使用的应用。 spring Boot应用启动器基本的一共有44种，具体如下 SpringBoot - starter 有哪些模块 二、springboot的启动类入口分析​ @SpringBootApplication : 是Sprnig Boot项目的核心注解，目的是开启自动配置。 ​ 1. @SpringBootApplication注解用于启动springboot。 ​ 2. @SpringBootApplication注解与@Configuration，@EnableAutoConfiguration，@ComponentScan等三个注解完全等价（前者是有后者三个注解合并而来的） ​ 三、深入探索 SpringApplication 执行流程略……. 四、IDEA创建项目之后的目录结果 src&#x2F;main&#x2F;java 目录下包括主程序入口类，可用来启动程序；及所需的接口 、类文件。 src&#x2F;main&#x2F;resources 是资源目录，存放一些配置信息。由于开发的web应用，因此在src&#x2F;main&#x2F;resources下产生了static子目录和template子目录，statis子目录存放静态资源（如css，js等文件）；templa子目录主要用于存放web页面动态视图文件。 pom.xml是项目管理的重要文件。 五、项目属性配置​ 1. 在springboot中主要通过application.properties文件、application.yml文件实现对属性的配置。 ​ 2. 这两种文件的格式不同，但内容对应、作用相同。 ​ 3. 配置文件的默认执行顺序是： ​ 项目根目录下的config子目录 -&gt; 项目根目录 -&gt; 项目classpath子目录下的config子目录 -&gt; 项目classpath子目录。 六、注解 @EnableAutoConfiguration Annotation：这个注解告诉 Spring Boot 根据你添加的 jar 依赖来“猜测”你想如何配置 Spring。由于 spring-boot-starter-web 添加了 Tomcat 和 Spring MVC，因此自动配置，假定您正在开发 Web 应用程序并会相应地设置 Spring。 七、The “main” Method ​ 我们应用程序的最后一部分是main 方法。这只是遵循应用程序入口点的 Java 约定的标准方法。 我们的 main 方法通过调用 run 委托给 Spring Boot 的SpringApplication 类。SpringApplication 引导我们的应用程序，启动 Spring，然后启动自动配置的 Tomcat Web 服务器。我们需要将 Example.class 作为参数传递给 run 方法来告诉 SpringApplication 哪个是主要的 Spring 组件。 args 数组也被传递以公开任何命令行参数。"},{"title":"jsp动态获取数据库数据并生成缩略图","date":"2022-04-09T05:36:44.000Z","url":"/2022/04/09/jsp%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E5%B9%B6%E7%94%9F%E6%88%90%E7%BC%A9%E7%95%A5%E5%9B%BE/","tags":[["jsp","/tags/jsp/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"],["jsp","/categories/%E5%89%8D%E7%AB%AF/jsp/"]],"content":"一、Controller层将数据存到session中 注意：response.getWriter().println(JsonUtil.toJsonString(pageBean)); 是ajax处理的 二、jsp代码 注：获取值用get（）方法…… 三、测试结果："},{"title":"ajax请求数据库图片数据回显","date":"2022-04-07T15:33:10.000Z","url":"/2022/04/07/ajax%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%E5%9B%9E%E6%98%BE/","categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"],["ajax","/categories/%E5%89%8D%E7%AB%AF/ajax/"]],"content":"一、jqeury用字符串拼接的ID选择器使用方式注： 单纯这样写，会用最后的图片路径，覆盖原来的图片路径（遍历每一个img都会执行6次赋值操作，以最后一个数据为准） 解决方法： 二、ajax请求 三、源码： 三、result： "},{"title":"SpringMVC拦截器","date":"2022-03-24T14:18:46.000Z","url":"/2022/03/24/SpringMVC%E6%8B%A6%E6%88%AA%E5%99%A8/","tags":[["Spring MVC","/tags/Spring-MVC/"]],"categories":[["Spring","/categories/Spring/"],["Spring MVC学习","/categories/Spring/Spring-MVC%E5%AD%A6%E4%B9%A0/"]],"content":"​ 早期MVC框架将一些通用操作写死在核心控制器中，致使框架灵活性不足、可扩展性降低。 Spring将预处理与后处理功能放到多个拦截器中实现，拦截器可自由选择和组合，增强了灵活性，有利于系统的解耦。SpringMVC的拦截器类似于Servlet中的过滤器Filter，用于对处理器进行预处理和后处理。 1、创建SpringMVC拦截器创建 SpringMVC 拦截器，只需要实现 HandlerInterceptor 接口即可。 接口中有三个方法需要实现： preHandle：该方法在 controller 执行前执行，可以实现对数据的预处理。 如果方法返回 true ，则继续调用下一个资源。如果返回为False，则Handle本身及postHandle&#x2F;afterCompletion以及后续的拦截器全部都不会再继续执行。 postHandle：该方法在处理器执行后，生成视图前执行。这里有机会修改视图层数据。 afterCompletion：Handle执行且视图渲染完成后执行 。最后执行，通常用于记录日志，释放资源，处理异常。 2、配置SpringMVC拦截器 3、测试 测试结果： (如果preHandle方法返回值为false，则目标方法不会再执行)"},{"title":"项目统一异常处理(未完待续...)","date":"2022-03-24T05:35:55.000Z","url":"/2022/03/24/%E9%A1%B9%E7%9B%AE%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","tags":[["Spring MVC","/tags/Spring-MVC/"]],"categories":[["Spring","/categories/Spring/"],["Spring MVC学习","/categories/Spring/Spring-MVC%E5%AD%A6%E4%B9%A0/"]],"content":"​ 在J2EE项目的开发中，不管是对底层的数据库操作过程，还是业务层的处理过程，还是控制层的处理过程，都不可避免会遇到各种可预知的、不可预知的异常需要处理。每个过程都单独处理异常，系统的代码耦合度高，工作量大且不好统一，维护的工作量也很大。 ​ 任何程序都会有异常。无论你是做什么项目，对异常的处理都是非常有必要的，尤其是web项目，因为它一般直接面向用户，所以良好的异常处理就显得格外的重要。 ​ Java异常体系简介 ​ Java相较于其它大多数语言提供了一套非常完善的异常体系Throwable：分为Error和Exception两大分支： Error：错误，对于所有的编译时期的错误以及系统错误都是通过Error抛出的，比如NoClassDefFoundError、硬件问题等等。 Exception：异常，是更为重要的一个分支，是程序员经常打交道的。异常定义为是程序的问题，程序本身是可以处理的。异常Exception它本身还分为两大重要的分支：Checked Exception（可检查异常，如IOException）和Unchecked Exception（不可检查异常，如RuntimeException）。 Error和Exception最大的区别是：异常是可以被程序处理的，而错误是没法处理的。 ​ 错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况（比如类找不到NoClassDefFoundError） ​ 对于与数据库相关的 Spring MVC 项目，我们通常会把 事务 配置在 Service层，当数据库操作失败时让 Service 层抛出运行时异常，Spring 事物管理器就会进行回滚。 ​ 如此一来，我们的 Controller 层就不得不进行 try-catch Service 层的异常，否则会返回一些不友好的错误信息到客户端。但是，Controller 层每个方法体都写一些模板化的 try-catch 的代码，很难看也难维护，特别是还需要对 Service 层的不同异常进行不同处理的时候。 只要设计得当，就再也不用在 Controller 层进行 try-catch 了！ ​ HTTP status codes： 异常类型 状态码 MissingPathVariableException 500 ConversionNotSupportedException 500 HttpMessageNotWritableException 500 AsyncRequestTimeoutException 503 MissingServletRequestParameterException 400 ServletRequestBindingException 400 TypeMismatchException 400 HttpMessageNotReadableException 400 MethodArgumentNotValidException 400 MissingServletRequestPartException 400 BindException 400 NoHandlerFoundException 404 HttpRequestMethodNotSupportedException 405 HttpMediaTypeNotAcceptableException 406 HttpMediaTypeNotSupportedException 415 1、使用web技术​ 在还没有Spring，更无Spring Boot时，开发使用的是源生的Servlet + tomcat容器。其实它也是提供了通用的异常的处理配置方式的。 ​ 使用web技术，需要在web.xml进行配置异常代码和异常跳转页面，然后程序中出现异常时，就会自动跳转到指定的异常页面。 2、HandlerExceptionResolver异常解析器HandlerExceptionResolver接口仅有一个resolveException方法用于处理异常 resolveException方法将返回ModelAndView类型的结果，返回值有如下约定： ​ ModelAndView对象中可以包含包含响应的错误的数据和一个要转发到的错误视图。如果异常在解析器中已被处理，并且不需要返回异常视图，则可以返回一个空的ModelAndView。​ 如果异常仍未解决，则返回null，以便后面的异常解析器继续尝试解决，如果解析器链执行完毕异常仍未解决，则该异常将直接向上抛出到 Servlet 容器。 测试​ （适合前后端不分离的情况） 方法一： 自定义异常类 异常视图页面 我们自定义一个异常解析器，用于将异常信息转发到error.jsp异常视图！ 自定义异常处理器 我们准备一个Controller，分别模拟抛出SysException和其他异常！ 测试异常 结果如下： 方法二： MyExceptionResolver.java ExceptionController.java Exception01.java Exception02、Exception03同上…. 测试结果： 3 、异常解析器链​ 我们可以通过在 Spring 配置中声明多个HandlerExceptionResolver的 bean，并根据需要设置其顺序属性来形成异常解析器链。并且支持order排序，order值越大，异常解析器的在链中的位置越靠后（解析器链实际上是一个List集合）。我们通过实现Ordered接口或者使用@Order注解来确定order值，如果不配置order值，那么默认为最大值，即Integer.MAX_VALUE，也就是说在链尾部！ ​ 当抛出异常时，DispatcherServlet将会依次调用异常解析器链的每一个析器的resolveException方法，如果当前异常解析器的resolveException方法返回null，那么表示未能成功处理该异常，那么继续调用下一个异常解析器，否则，表示异常处理器成功，不会继续调用后续的解析器！ ​ 如：新建另一个异常解析器SysExceptionResolver2，它的order值为0，小于2，因此它将会被先于SysExceptionResolver调用！ ​ 如果将SysExceptionResolver2的@Order注解值改为大于2，或者去掉该注解，那么SysExceptionResolver将会先被调用： 4、@ExceptionHandler统一异常处理​ Spring提供了HandlerExceptionResolver的几个默认实现，它们具有自己的可扩展的解决异常的方式，我们完全可以直接利用这些默认实现，只需要配置对应的异常处理的方案，而无需再自定义HandlerExceptionResolver，无需自己编写完整的异常处理逻辑！ ​ ExceptionHandlerExceptionResolver通过调用在@Controller类或者@ControllerAdvice类中的具有@ExceptionHandler注解的方法来解决来自Controller方法的异常，这实际上就是一种非常常用并且简单的处理异常的方式，在目前的项目中，大多使用该方式！ "},{"title":"bootstrap-table分页","date":"2022-03-21T13:10:20.000Z","url":"/2022/03/21/bootstrap-table%E5%88%86%E9%A1%B5/","tags":[["bootstrap-table","/tags/bootstrap-table/"]],"categories":[["前端框架","/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"],["bootstrap-table","/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/bootstrap-table/"]],"content":"一、bootstrap-table客户端分页：​ 数据库查询所有的数据，在前端进行分页 ​ 直接返回List&lt;&gt; 类型的数据即可 （rows: [{},{},,]） 二、bootstrap-table服务端分页：​ 每次只查询当前页面加载所需要的那几条数据, 从数据库返回 数据要这种json格式： 代码示例： 用来接收客户端发来的分页请求（offset，pageNumber） controller层向客户端发送分页的json格式数据 controller层 dao层使用了mybatis，在接口出写好sql语句 mybatis配置文件 spring-dao.xml "},{"title":"声明式事务控制","date":"2022-03-20T10:39:05.000Z","url":"/2022/03/20/%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/","tags":[["Spring注解","/tags/Spring%E6%B3%A8%E8%A7%A3/"]],"categories":[["Spring","/categories/Spring/"],["Spring注解驱动学习","/categories/Spring/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/"]],"content":"一、什么是声明式事务控制​ Spring 的声明式事务顾名思义就是采用声明的方式来处理事务。这里所说的声明，就是指在配置文件中声明，用在 Spring 配置文件中声明式的处理事务来代替代码式的处理事务。 ​ 1. 搭建声明式事务的环境​ 对数据库进行增删改操作时，必然是要使用到事务的。因此，接下来，我们就来搭建好声明式事务的基本环境。 导入相关依赖: JdbcConfig.java配置类 ​ 配置数据源以及JdbcTemplate: ​ 1. 首先，我们得向IOC容器中注册一个c3p0数据源，那么如何做到这一点呢？很简单，先新建一个配置类，例如TxConfig，再使用@Bean注解向IOC容器中注册一个c3p0数据源，如下所示。 JdbcConfig.java配置类 然后，再向IOC容器中注册一个JdbcTemplate组件，它是Spring提供的一个简化数据库操作的工具，它能简化对数据库的增删改查操作。 注册一个JdbcTemplate组件 ​ 注意，在创建JdbcTemplate对象的时候，得把数据源传入JdbcTemplate类的有参构造器中，因为需要从数据源里面获取数据库连接。 ​ 为什么可以这样做呢？因为@Bean注解标注的方法在创建对象的时候，方法参数的值是从IOC容器中获取的，并且标注在这个方法的参数上的@Autowired注解可以省略。 ​ 这种方式就不用那么麻烦了，在JdbcTemplate类的有参构造器中调用一次dataSource()方法即可。可以看到，向IOC容器中注册一个JdbcTemplate组件时，使用的就是这种方式。 ​ 有些同学可能会有一些疑问，TxConfig配置类的dataSource()方法是向IOC容器中注册一个c3p0数据源的，该方法的逻辑也很简单，就是创建一个c3p0数据源并将其返回出去，而在向IOC容器中注册一个JdbcTemplate组件时，会在其有参构造器中调用一次dataSource()方法，那岂不是又会创建一个c3p0数据源呢？不知你会不会有这样一个疑问，反正我是有的。 ​ 其实，并不会再创建一个c3p0数据源，因为对于Spring的配置类而言，只要某个方法是给IOC容器中注册组件的，那么我们第二次调用该方法，就相当于是从IOC容器中找组件，而不是说把该方法再运行一遍。 ​ 总结一下，Spring对@Configuration注解标注的类会做特殊处理，多次调用给IOC容器中添加组件的方法，都只是从IOC容器中找组件而已。 ​ ​ 在Service组件中，使用@Transactional注解，就可以给业务方法添加事务管理。 注意： 需要事务管理的service，在方法上加上@Transactional 注解即可。 必须为public方法才行,不要捕捉异常，要让异常自动抛出，否则不能进行事务回滚。 二、声明式事务处理的作用 事务管理不侵入开发的组件。具体来说，业务逻辑对象就不会意识到正在事务管理之中，事实上也应该如此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，如果想要改变事务管理策划的话，也只需要在定义文件中重新配置即可。 在不需要事务管理的时候，只要在设定文件上修改一下，即可移去事务管理服务，无需改变代码重新编译，这样维护起来极其方便。 注意：Spring 声明式事务控制底层就是AOP。 ​ 编程式事务控制三大对象： PlatformTransactionManager TransactionDefinition TransactionStatus 三、事务传播行为@Transactional 注解中的 propagation 属性，可以设置事务传播行为。属性值为： REQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，就加入到这个事务中。这是最常见的选择。 SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行。 MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常。 REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起。 NOT_SUPPORTED：以非事务方式执行操作，如果存在事务，就把当前事务挂起。 NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。 超时时间：默认值是-1，没有超时限制。如果有，以秒为单位进行设置 是否只读：建议查询时设置为只读 ​ 接下来，我们就为Service类中的getDeptById()方法添加上事务，添加上事务以后，只要这个方法里面有任何一句代码出现了问题，那么该行代码之前执行的所有操作就都应该回滚。 ​ 如果要想为该方法添加上事务，那么就得使用@Transactional注解了。我们在该方法上标注这么一个注解，就是为了告诉Spring这个方法它是一个事务方法，这样，Spring在执行这个方法的时候，就会自动地进行事务控制。如果该方法正常执行，没出现任何问题，那么该方法中的所有操作都会生效，最终就会提交；如果该方法运行期间出现异常，那么该方法中的所有操作都会回滚。 ​ 光为getDeptById()方法加一个@Transactional注解是不行的，那我们还得做什么呢？还得在配置类上标注一个@EnableTransactionManagement注解，来开启基于注解的事务管理功能。 ​ 如果是像以前一样基于配置文件来开发，那么就得在配置文件中添加如下这样一行配置，来开启基于注解的事务管理功能。 四、声明式事务控制的实现​ 声明式事务控制明确事项： 谁是切点？ 谁是通知？ 配置切面？ 五、添加事务管理​ Spring为了支持事务管理，专门封装了事务管理对象。我们只要在Spring容器中配置这个对象，即可使用。 ​ 在Spring容器中添加事务管理的配置： xml配置文件 注解方式的配置 ​ 在主配置类上标注一个@EnableTransactionManagement注解，来开启基于注解的事务管理功能，为需要实现的方法添加上事务，那么就得使用@Transactional注解。如： "},{"title":"AOP入门","date":"2022-03-19T14:39:22.000Z","url":"/2022/03/19/AOP%E5%85%A5%E9%97%A8/","tags":[["Spring注解","/tags/Spring%E6%B3%A8%E8%A7%A3/"]],"categories":[["Spring","/categories/Spring/"],["Spring注解驱动学习","/categories/Spring/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/"]],"content":"1. Spring 的 AOP 简介1.1 什么是 AOP​ AOP 为 Aspect Oriented Programming 的缩写，意思为面向切面编程，是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 ​ AOP 是 OOP 的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 简单的说它就是把我们程序重复的代码抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码的基础上，对我们的已有方法进行增强。 ​ 1.2 AOP 的作用及其优势 作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强 优势：减少重复代码，提高开发效率，并且便于维护 1.3 AOP 的底层实现​ 实际上，AOP 的底层是通过 Spring 提供的的动态代理技术实现的。在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。 1.4 AOP 的动态代理技术动态代理是一种常用的设计模式，广泛应用于框架中，Spring框架的AOP特性就是应用动态代理实现的。 常用的动态代理技术 实现动态代理有两种形式： jdk动态代理：根据目标类接口获取代理类实现规则，生成代理对象。这个代理对象，也是目标类接口的一个实现类。 cglib动态代理：根据目标类本身获取代理类实现规则，生成代理对象。这个代理对象，也是目标类的一个子类。 （如果目标类为final，则不能使用CGLib实现动态代理） SpringAOP可以自动在jdk动态代理和CGLib动态代理之间进行切换，规则如下： 如果目标对象实现了接口，采用jdk动态代理实现aop。 如果目标对象没有实现接口，采用CGLib动态代理实现aop。 如果目标对象实现了接口，但仍然想要使用CGLIB实现aop，可以手动进行配置。 cglib动态代理： 注意： dao层不能再实现接口。 service层不能再实现接口。 1.5 AOP 相关概念 Target（目标对象）：代理的目标对象。 Proxy （代理）：一个类被 AOP 织入增强后，就产生一个结果代理类。 Joinpoint（连接点）：所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点。 Pointcut（切入点）：所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义。 Advice（通知&#x2F; 增强）：所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知。 Aspect（切面）：是切入点和通知（引介）的结合。 Weaving（织入）：是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入， 而 AspectJ 采用编译期织入和类装载期织入。 1.6 AOP 开发明确的事项1.6.1 需要编写的内容​ 1. 编写核心业务代码（目标类的目标方法） ​ 2. 编写切面类，切面类中有通知(增强功能方法) ​ 3. 在配置文件中，配置织入关系，即将哪些通知与哪些连接点进行结合 1.6.2 AOP 技术实现的内容​ Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。 1.6.3 AOP 底层使用哪种代理方式​ 在 spring 中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。 1.7 知识要点 aop：面向切面编程 aop底层实现：基于JDK的动态代理 和 基于Cglib的动态代理 aop的重点概念：* Pointcut（切入点）：被增强的方法 * Advice（通知&#x2F; 增强）：封装增强业务逻辑的方法 * Aspect（切面）：切点+通知 * Weaving（织入）：将切点与通知结合的过程 开发明确事项： 谁是切点（切点表达式配置） 谁是通知（切面类中的增强方法） 将切点和通知进行织入配置 2. 导入依赖 ​ Aspectj是一个基于java的、面向切面的AOP框架。Spring2.0之后增加了对Aspectj切点表达式的支持。而实际开发中一般都使用Aspectj方式来实现AOP。所以还要导入Aspectj相关jar包。 3. 切点表达式的写法3.1 表达式语法：​ execution([修饰符] 返回值类型 包名.类名.方法名(参数)) 访问修饰符可以省略 返回值类型、包名、类名、方法名可以使用星号* 代表任意 包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类 参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表 例如： 3.2 Spring AOP支持的切入点指示符：(1)execution:用来匹配执行方法的连接点 A:@Pointcut(“execution(* com.aijava.springcode.service..*.*(..))”) B:@Pointcut(“within(com.aijava.springcode.service.*)”) within限定匹配方法的连接点,上面的就是表示匹配service包下的任意连接点 C:@Pointcut(“this(com.aijava.springcode.service.UserService)”) this用来限定AOP代理必须是指定类型的实例，如上，指定了一个特定的实例，就是UserService D:@Pointcut(“bean(userService)”) bean也是非常常用的,bean可以指定IOC容器中的bean的名称 4. 基于注解的 AOP 开发4.1 基于注解的aop开发步骤​ ① 创建目标接口和目标类（内部有切点）​ ② 创建切面类（内部有增强方法）​ ③ 将目标类和切面类的对象创建权交给 spring​ ④ 在切面类中使用注解配置织入关系​ ⑤ 在配置文件中开启组件扫描和 AOP 的自动代理​ ⑥ 测试 4.2 使用步骤 @EnableAspectJAutoProxy(proxyTargetClass &#x3D; false)：声明自动为spring容器中那些配置@Aspect切面的bean创建代理，织入切面。开启基于注解的aop模式 @Aspect：定义切面类，切面类里定义通知 @PointCut 切入点，可以写切入点表达式，指定在哪个方法切入 JoinPoint：连接点,是一个类，配合通知使用，用于获取切入的点的信息 通知的类型： 名称 注解 说明 前置通知 @Before 用于配置前置通知。指定增强的方法在切入点方法之前执行 后置通知 @AfterReturning 用于配置后置通知。指定增强的方法在切入点方法之后执行 环绕通知 @Around 用于配置环绕通知。指定增强的方法在切入点方法之前和之后都执行 异常抛出通知 @AfterThrowing 用 用于配置异常抛出通知。指定增强的方法在出现异常时执行 最终通知 @After 用于配置最终通知。无论增强方式执行是否有异常都会执行 ​ 注： 连接点（JoinPoint 就是要织入的业务方法） ​ 在实际开发中，除了业务逻辑这个主要功能之外，还需要处理许多辅助功能。 比如：日志、异常处理、事务、输入验证、安全等等，我们将这些代码称为：方面代码。而方面代码，就是我们要抽取出来的。 下面抽取日志方面代码： @Aspect注解：定义此类为方面代码，即是一个通知。 @Before注解：定义一个前置通知。即在目标方法执行前切入此注解标注的方法。 execution() 是一个Aspect表达式，语法为：execution(返回值类型 包名.类名.方法名 (参数) 异常) 4.3 AOP底层实现Jdk代理：基于接口的代理，一定是基于接口，会生成目标对象的接口的子对象。 Cglib代理：基于类的代理，不需要基于接口，会生成目标对象的子对象。 注解@EnableAspectJAutoProxy开启代理; 如果属性proxyTargetClass默认为false, 表示使用jdk动态代理织入增强; 如果属性proxyTargetClass设置为true，表示使用Cglib动态代理技术织入增强; 如果属性proxyTargetClass设置为false，但是目标类没有声明接口， Spring aop还是会使用Cglib动态代理，也就是说非接口的类要生成代理都用Cglib。 4.4 快速入门​ 通过注解**@Pointcut*定义切点，pointCut*()只是一个标识，无所谓是什么， ​ 方法中内容本身也是空的，使用该切点的地方直接通过标识 pointCut()引用切点表达式。 Operator.java 注意： 如果配置了环绕通知，那么业务方法的执行将在环绕通知中的obj &#x3D; pjp.proceed();这段代码时开始执行。此时要注意：如果环绕通知方法不写返回值，或者obj &#x3D; pjp.proceed()这段代码如果不取得返回值，那么返回通知也不能取得返回值。 有了环绕通知，异常通知也将失去作用。 实际上，如果要配置环绕通知，那么其他通知就失去意义了。因为在环绕通知中，也可以在方法执行前、执行后做方面代码，包括获取返回值、做异常处理等。 UserService.java 测试 注解版的配置文件，相当于xml 运行结果： 5. 为什么用aop​ 1. 就是为了方便，看一个国外很有名的大师说，编程的人都是“懒人”，因为他把自己做的事情都让程序做了。用了aop能让你少写很多代码，这点就够充分了吧 2. 就是为了更清晰的逻辑，可以让你的业务逻辑去关注自己本身的业务，而不去想一些其他的事情，这些其他的事情包括：安全，事物，日志等。 3. 那些AOP的术语 初看这么多术语，一下子都不好接受，慢慢来，很快就会搞懂。 1.通知（Advice） 就是你想要的功能，也就是上面说的 安全，事物，日志等。你给先定义好把，然后在想用的地方用一下。 2.连接点（JoinPoint） 这个更好解释了，就是spring允许你使用通知的地方，那可真就多了，基本每个方法的前，后（两者都有也行），或抛出异常时都可以是连接点，spring只支持方法连接点.其他如aspectJ还可以让你在构造器或属性注入时都行，不过那不是咱关注的，只要记住，和方法有关的前前后后（抛出异常），都是连接点。 3.切入点（Pointcut） 上面说的连接点的基础上，来定义切入点，你的一个类里，有15个方法，那就有几十个连接点了对把，但是你并不想在所有方法附近都使用通知（使用叫织入，以后再说），你只想让其中的几个，在调用这几个方法之前，之后或者抛出异常时干点什么，那么就用切点来定义这几个方法，让切点来筛选连接点，选中那几个你想要的方法。 4.切面（Aspect） 切面是通知和切入点的结合。现在发现了吧，没连接点什么事情，连接点就是为了让你好理解切点，搞出来的，明白这个概念就行了。通知说明了干什么和什么时候干（什么时候通过方法名中的before,after，around等就能知道），而切入点说明了在哪干（指定到底是哪个方法），这就是一个完整的切面定义。 5.引入（introduction） 允许我们向现有的类添加新方法属性。这不就是把切面（也就是新方法属性：通知定义的）用到目标类中吗 6.目标（target） 引入中所提到的目标类，也就是要被通知的对象，也就是真正的业务逻辑，他可以在毫不知情的情况下，被咱们织入切面。而自己专注于业务本身的逻辑。 7.代理(proxy) 怎么实现整套aop机制的，都是通过代理，这个一会给细说。 8.织入(weaving) 把切面应用到目标对象来创建新的代理对象的过程。有3种方式，spring采用的是运行时，为什么是运行时，后面解释。 关键就是：切点定义了哪些连接点会得到通知 ​ 6. aop原理 spring用代理类包裹切面，把他们织入到Spring管理的bean中。也就是说代理类伪装成目标类，它会截取对目标类中方法的调用，让调用者对目标类的调用都先变成调用伪装类，伪装类中就先执行了切面，再把调用转发给真正的目标bean。 现在可以自己想一想，怎么搞出来这个伪装类，才不会被调用者发现（过JVM的检查，JAVA是强类型检查，哪里都要检查类型）。 1.实现和目标类相同的接口，我也实现和你一样的接口，反正上层都是接口级别的调用，这样我就伪装成了和目标类一样的类（实现了同一接口，咱是兄弟了），也就逃过了类型检查，到java运行期的时候，利用多态的后期绑定（所以spring采用运行时），伪装类（代理类）就变成了接口的真正实现，而他里面包裹了真实的那个目标类，最后实现具体功能的还是目标类，只不过伪装类在之前干了点事情（写日志，安全检查，事物等）。 这就好比，一个人让你办件事，每次这个时候，你弟弟就会先出来，当然他分不出来了，以为是你，你这个弟弟虽然办不了这事，但是他知道你能办，所以就答应下来了，并且收了点礼物（写日志），收完礼物了，给把事给人家办了啊，所以你弟弟又找你这个哥哥来了，最后把这是办了的还是你自己。但是你自己并不知道你弟弟已经收礼物了，你只是专心把这件事情做好。 顺着这个思路想，要是本身这个类就没实现一个接口呢，你怎么伪装我，我就压根没有机会让你搞出这个双胞胎的弟弟，那么就用第2种代理方式，创建一个目标类的子类，生个儿子，让儿子伪装我 2.生成子类调用，这次用子类来做为伪装类，当然这样也能逃过JVM的强类型检查，我继承的吗，当然查不出来了，子类重写了目标类的所有方法，当然在这些重写的方法中，不仅实现了目标类的功能，还在这些功能之前，实现了一些其他的（写日志，安全检查，事物等）。 这次的对比就是，儿子先从爸爸那把本事都学会了，所有人都找儿子办事情，但是儿子每次办和爸爸同样的事之前，都要收点小礼物（写日志），然后才去办真正的事。当然爸爸是不知道儿子这么干的了。这里就有件事情要说，某些本事是爸爸独有的(final的)，儿子学不了，学不了就办不了这件事，办不了这个事情，自然就不能收人家礼了。 前一种兄弟模式，spring会使用JDK的java.lang.reflect.Proxy类，它允许Spring动态生成一个新类来实现必要的接口，织入通知，并且把对这些接口的任何调用都转发到目标类。 后一种父子模式，spring使用CGLIB库生成目标类的一个子类，在创建这个子类的时候，spring织入通知，并且把对这个子类的调用委托到目标类。 相比之下，还是兄弟模式好些，他能更好的实现松耦合，尤其在今天都高喊着面向接口编程的情况下，父子模式只是在没有实现接口的时候，也能织入通知，应当做一种例外。 ————————————————AOP部分原文链接："},{"title":"数据连接池注解学习入门","date":"2022-03-19T14:17:18.000Z","url":"/2022/03/19/%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/","tags":[["Spring","/tags/Spring/"]],"categories":[["Spring","/categories/Spring/"],["Spring注解驱动学习","/categories/Spring/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/"]],"content":"数据源的手动创建 @Configuration @ComponentScan @Import 读取jdbc.properties配置文件创建连接池 @PropertySource @value 创建C3P0连接池@Bean 测试加载核心配置类创建Spring容器"},{"title":"加载配置文件","date":"2022-03-19T13:56:55.000Z","url":"/2022/03/19/%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","tags":[["Spring","/tags/Spring/"]],"categories":[["Spring","/categories/Spring/"],["Spring注解驱动学习","/categories/Spring/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/"]],"content":"​ IDEA: 如 jdbc.properties配置文件存在resource资源文件夹里 方法一： 方法二： PropertySource注解:引入jdbc属性资源文件"},{"title":"对IoC(控制反转)和DI(依赖注入)的理解","date":"2022-03-19T13:34:39.000Z","url":"/2022/03/19/%E5%AF%B9IoC-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC-%E5%92%8CDI-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-%E7%9A%84%E7%90%86%E8%A7%A3/","tags":[["Spring","/tags/Spring/"]],"categories":[["Spring","/categories/Spring/"],["理论理解","/categories/Spring/%E7%90%86%E8%AE%BA%E7%90%86%E8%A7%A3/"]],"content":"一、IoC是什么​ IOC的作用：降低程序之间的耦合（依赖关系） 概念：依赖关系的管理交给spring维护，在当前类需要用到其他类的对象，由spring为我们提供，只需在配置文件中说明关系的维护； Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。 ​ 在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下： ● 谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；**谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。 ​ ● 为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。 二、DI依赖注入 DI—Dependency Injection，即“依赖注入”：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。 理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下： ●谁依赖于谁：当然是应用程序依赖于IoC容器； ●为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源； ●谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象； ●注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。 IoC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。 看过很多对Spring的Ioc理解的文章，好多人对Ioc和DI的解释都晦涩难懂，反正就是一种说不清，道不明的感觉，读完之后依然是一头雾水，感觉就是开涛这位技术牛人写得特别通俗易懂，他清楚地解释了IoC(控制反转) 和DI(依赖注入)中的每一个字，读完之后给人一种豁然开朗的感觉。我相信对于初学Spring框架的人对Ioc的理解应该是有很大帮助的。 三、我对IoC(控制反转)和DI(依赖注入)的理解 在平时的java应用开发中，我们要实现某一个功能或者说是完成某个业务逻辑时至少需要两个或以上的对象来协作完成，在没有使用Spring的时候，每个对象在需要使用他的合作对象时，自己均要使用像new object() 这样的语法来将合作对象创建出来，这个合作对象是由自己主动创建出来的，创建合作对象的主动权在自己手上，自己需要哪个合作对象，就主动去创建，创建合作对象的主动权和创建时机是由自己把控的，而这样就会使得对象间的耦合度高了，A对象需要使用合作对象B来共同完成一件事，A要使用B，那么A就对B产生了依赖，也就是A和B之间存在一种耦合关系，并且是紧密耦合在一起，而使用了Spring之后就不一样了，创建合作对象B的工作是由Spring来做的，Spring创建好B对象，然后存储到一个容器里面，当A对象需要使用B对象时，Spring就从存放对象的那个容器里面取出A要使用的那个B对象，然后交给A对象使用，至于Spring是如何创建那个对象，以及什么时候创建好对象的，A对象不需要关心这些细节问题(你是什么时候生的，怎么生出来的我可不关心，能帮我干活就行)，A得到Spring给我们的对象之后，两个人一起协作完成要完成的工作即可。 所以控制反转IoC(Inversion of Control)是说创建对象的控制权进行转移，以前创建对象的主动权和创建时机是由自己把控的，而现在这种权力转移到第三方，比如转移交给了IoC容器，它就是一个专门用来创建对象的工厂，你要什么对象，它就给你什么对象，有了 IoC容器，依赖关系就变了，原先的依赖关系就没了，它们都依赖IoC容器了，通过IoC容器来建立它们之间的关系。 这是我对Spring的IoC**(控制反转)的理解。DI(依赖注入)其实就是IOC的另外一种说法，DI是由Martin Fowler 在2004年初的一篇论文中首次提出的。他总结：控制的什么被反转了？就是：获得依赖对象的方式反转了。**"},{"title":"使用@Bean注解","date":"2022-03-19T13:31:59.000Z","url":"/2022/03/19/%E4%BD%BF%E7%94%A8-Bean-%E6%B3%A8%E8%A7%A3/","tags":[["Spring注解","/tags/Spring%E6%B3%A8%E8%A7%A3/"]],"categories":[["Spring","/categories/Spring/"],["Spring注解驱动学习","/categories/Spring/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/"]],"content":"@Bean是方法级注解，您可以在@Configuration注解的类或@Component注解 的类中使用@Bean注解。 ​ 要声明 bean，可以使用@Bean注解 对方法进行 注解。您可以使用此方法在指定为该方法的返回值的类型的ApplicationContext内注册 bean 定义。默认情况下，Bean 名称与方法名称相同。 ​ bean 名称以小写字母开头，并从那里用驼峰式大小写。这样的名称的示例包括accountManager，accountService，userDao，loginController等。 以下示例显示了使用@Bean注解的方法声明： 前面的配置与下面的 Spring 的XML文件相关配置完全等效： ​ 即：transferService -&gt; com.acme.TransferServiceImpl ​ 这两个声明使一个名为transferService的 bean 在ApplicationContext中可用，并绑定到TransferServiceImpl类型的对象实例 自定义 Bean 命名 ​ 默认情况下，配置类使用@Bean方法的名称作为结果 bean 的名称。但是，可以使用name属性覆盖此功能，如以下示例所示： ​ 有时希望为单个 bean 提供多个名称，否则称为 bean 别名。 @Bean注解的name属性为此目的接受一个 String 数组。以下示例说明如何为 bean 设置多个别名： "},{"title":"“Git报错解决errno 10054”","date":"2022-03-19T08:02:55.000Z","url":"/2022/03/19/Git%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/","tags":[["Git报错","/tags/Git%E6%8A%A5%E9%94%99/"]],"categories":[["报错信息合集","/categories/%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF%E5%90%88%E9%9B%86/"]],"content":"Git报错解决 : Connection was reset, errno 10054“造成这个错误很有可能是网络不稳定，连接超时导致的” 以执行下面的命令。 打开Git命令页面，执行git命令脚本：修改设置，解除ssl验证 git config –global http.sslVerify false” "},{"title":"spring注解学习-01","date":"2022-03-19T02:15:35.000Z","url":"/2022/03/19/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0-01/","tags":[["Spring注解驱动","/tags/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8/"]],"categories":[["Spring","/categories/Spring/"],["Spring注解驱动学习","/categories/Spring/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/"]],"content":"Spring注解开发 注解 说明 @Component 使用在类上用于实例化Bean @Controller 使用在web层类上用于实例化Bean @Service 使用在service层类上用于实例化Bean @Repository 使用在dao层类上用于实例化Bean @Autowired 使用在字段上用于根据类型依赖注入 @Qualifier 结合@Autowired一起使用用于根据名称进行依赖注入 @Resource 相当于@Autowired+@Qualifier，按照名称进行注入 @Value 注入普通属性 @Scope 标注Bean的作用范围 @PostConstruct 使用在方法上标注该方法是Bean的初始化方法 @PreDestroy 使用在方法上标注该方法是Bean的销毁方法 一、@Configuration@Configuration是类级别的注解，指示对象是 Bean 定义的源。 ​ @Bean注解用于表示一个方法实例化、配置和初始化一个由 Spring IoC 容器管理的新对象。最常与@Configuration 一起使用。 实体类 配置类 测试 测试结果 注：可根据过滤规则，过滤指定的组件（这里指定的是Controller组件） 二、懒加载@Lazy：如果我们想要 Spring 在启动的时候延迟加载 bean，即在调用某个 bean 的时候再去初始化，那么就可以使用 @Lazy 注解。 单实例bean，默认在容器启动的时候创建对象 懒加载：容器启动不创建对象，第一次使用才获取Bean创建对象，并初始化 测试结果：没加懒加载的运行结果： 加了懒加载的运行结果： ​ "},{"title":"客户端表单提交及接收后台json格式数据content-type问题","date":"2022-03-17T16:22:54.000Z","url":"/2022/03/18/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4%E5%8F%8A%E6%8E%A5%E6%94%B6%E5%90%8E%E5%8F%B0json%E6%A0%BC%E5%BC%8F%E6%95%B0%E6%8D%AEcontent-type%E9%97%AE%E9%A2%98/","tags":[["报错信息","/tags/%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF/"]],"categories":[["报错信息合集","/categories/%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF%E5%90%88%E9%9B%86/"]],"content":"org.springframework.web.HttpMediaTypeNotSupportedException: Content type ‘application&#x2F;json;charset&#x3D;UTF-8’ not supported或其他Content type不支持处理 记录在ssm项目遇到的报错信息，以积累经验 报错原因：​ form表单的post编码是content-type:application&#x2F;x-www-form-urlencoded， ​ 我觉得吧，一直报错不支持json格式就是因为后台返回的数据跟客户端的请求头content-type格式不一致导致的，因为原本是用form标签，一直改不了它接收json的格式，而我们需要接收的是json格式的数据，就需要‘application&#x2F;json’格式的content-type，所有就一直报415的错。 解决方法：​ 后来我换条思路，干脆不要form标签了，直接用div标签做成跟原本一样的，button按钮提交，结合ajax这样，后来浏览器里的content-type不再是application&#x2F;x-www-form-urlencoded，json格式的数据也成功接收到，因此问题就解决了。 源码： 运行结果： 后台获取到的数据（测试） 登录成功跳转其他页面 "},{"title":"Hello World","date":"2022-03-09T04:55:52.786Z","url":"/2022/03/09/hello-world/","categories":[["test","/categories/test/"]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 喵呼呼o(&#x3D;•ェ•&#x3D;)m 成功啦o(￣▽￣)ブ 有危险Σ(っ °Д °;)っ 有消息(・∀・(・∀・(・∀・*) 当心哦≧ ﹏ ≦ 这是红色字体 这是绿色字体 这是黄色字体 这是蓝色字体 为字体加颜色 抽屉式代码展示 开始测试Create a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment hexo cl &amp;&amp; hexo g &amp;&amp; hexo d"}]