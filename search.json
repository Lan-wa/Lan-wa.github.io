[{"title":"SweetAlert2实践","date":"2022-05-08T08:46:11.000Z","url":"/2022/05/08/SweetAlert2%E5%AE%9E%E8%B7%B5/","categories":[["前端框架","/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"],["SweetAlert2","/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/SweetAlert2/"]],"content":"SweetAlert2 实践 一、多重弹窗（重复确认） ( focusCancel: true自动聚焦取消键， 按钮还是左边取消键看得舒服一点 强迫症reverseButtons: true ) 测试截图： 二、在SweetAlert2中添加html标签内容SweetAlert2测试如图： 我拿bootstrap的模态框对比： 虽然两个都好看，但还是觉得bootstrap的模态框更好用，写起来更方便。 话不多说了 先放上sweetAlert的测试代码： 注：这里的msg数据为空，仅仅是测试，数据获取可通过用ajax返回后台数据即可。 三、与Ajax搭配使用下面展示的测试登录案例： 运行截图： 只完成登录成功显示的部分， 后台返回的msg，如密码错误等信息显示还未显示，时间充裕的话再补上吧 ! "},{"title":"sweetAlert2","date":"2022-05-08T08:05:27.000Z","url":"/2022/05/08/sweetAlert2/","categories":[["前端框架","/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"],["SweetAlert2","/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/SweetAlert2/"]],"content":"官方文档： 一、简介SweetAlert2用于替代浏览器默认的弹出对话框，是一个美观，响应，可定制，可访问替代JAVASCRIPT的弹出框。传统的弹窗相比之下实属不好看，而SweetAlert2能帮我们解决这个问题。 二、安装 三、 快速入门 四、常用配置 title：模态的标题 text：模态的描述。如果同时提供“text”和“html”参数，则将使用“text”。 type：模态的类型。SweetAlert2附带5种内置类型，可显示相应的图标动画：warning, error, success, info, 和 question。它可以放在键“type”下的数组中，也可以作为函数的第三个参数传递。 footer: 莫代尔的页脚。可以是纯文本或HTML。 toast: 是否应将警报视为Toast通知。此选项通常与position参数和计时器耦合。Toast永远不会自动聚焦。( 如上示例) width：模态窗口宽度，包括填充 (box-sizing: border-box).可以是px 或 %. 默认宽度为 32rem. padding：模态窗口填充。默认填充为 1.25rem. background：模态窗口背景（CSS背景属性）。默认背景为**’#fff’**. position：模态窗口位置可以是**’top’**, ‘top-start’, ‘top-end’, ‘center’, ‘center-start’, ‘center-end’, ‘bottom’, ‘bottom-start’, 或 ‘bottom-end’. 默认值是 *’center’*。 timer：自动关闭模态的计时器。以ms（毫秒）为单位。 animation：默认值为true。如果设置为false，则将禁用模态CSS动画。 preConfirm：在确认之前执行的功能可以是异步（Promise-returning）或同步。 false以防止弹出窗口关闭 别的传递该值作为result.value 的 Swal.fire() undefined 保留默认的 result.value 按键 allowEnterKey：默认值为true。如果设置为false，则用户无法通过按Enter键或空格键确认模态，除非他们手动对焦确认按钮。您还可以传递返回布尔值的自定义函数。 allowEscapeKey：默认为true。如果设置为false，则用户无法通过按键关闭模式Esc。您还可以传递返回布尔值的自定义函数，例如，如果要禁用Esc模式加载状态的键。 allowOutsideClick：默认值为true。如果设置为false，则用户无法通过单击外部来解除模态。 showConfirmButton：默认值为true。如果设置为false，则不会显示“确认”按钮。当您使用自定义HTML描述时，它会很有用。 showCancelButton：默认值为false。如果设置为true，将显示“取消”按钮，用户可以单击该按钮以关闭模式。 confirmButtonText：使用此选项可更改“确认”按钮上的文本。 cancelButtonText：使用此选项可更改”Cancel”按钮上的文本。 confirmButtonColor： 使用此选项可更改”Confirm”按钮的背景颜色。默认颜色为**#3085d6**。（其它按键类似） 我们可以通过使用**Swal.mixin({ …options })**创建自己的Swal来轻松地重用配置 五、弹出的五种类型： 六、方法 方法 描述 Swal.isVisible() 确定是否显示模态。 Swal.mixin({ …options }) 返回包含params作为默认值的Swal的扩展版本。用于重用Swal配置。 Swal.update({ …options }) 更新弹出选项。 Swal.close() 以编程方式关闭当前打开的SweetAlert2模式，Swal.fire（）返回的Promise 将使用空对象{}解析 Swal.getContainer() 获取包含背景的弹出容器。 Swal.getHeader() 获取模态标题。标题包含进度步骤，图标，图像，标题和关闭按钮。 Swal.getTitle() 获得模态标题。 Swal.getCloseButton() 获取关闭按钮。 Swal.getContent() 获取模态内容。 Swal.getImage() 获取image. Swal.getActions() 获取动作块（按钮容器）。 Swal.getFooter() 得到模态页脚。 Swal.getFocusableElements() 获取弹出窗口中的所有可聚焦元素。 Swal.getConfirmButton() 获取 “Confirm” 按钮. Swal.getCancelButton() 获取 “Cancel” 按钮. Swal.enableButtons() 启用 “Confirm” 和 “Cancel” 按钮. Swal.disableButtons() 禁用 “Confirm” 和 “Cancel” 按钮. Swal.enableConfirmButton() 已弃用并将在下一个主要版本中删除，请改用Swal.getConfirmButton(). 仅启用”Confirm”按键 Swal.disableConfirmButton() 已弃用并将在下一个主要版本中删除，请改用Swal.getConfirmButton() . 仅禁用”Confirm”按键 Swal.showLoading() or Swal.enableLoading() 禁用按钮和显示加载程序。这对AJAX请求很有用。 Swal.hideLoading() or Swal.disableLoading() 启用按钮并隐藏加载程序。 Swal.isLoading() 确定模态是否处于加载状态。相关方法：Swal.showLoading() 和 Swal.hideLoading() Swal.getTimerLeft() 返回设置 timer 参数时剩余的时间。 Swal.stopTimer() 如果设置了timer参数，则停止计时器。返回剩余的时间 Swal.resumeTimer() 恢复先前停止的timer。返回剩余的时间 Swal.toggleTimer() 在已停止和正在运行之间切换timer状态。返回剩余的时间 Swal.isTimerRunning() 返回timer的状态：如果正在运行，则为true;如果已暂停，则为false Swal.increaseTimer(n) 增加timer by n 毫秒。返回剩余的时间 Swal.clickConfirm() 以编程方式单击”Confirm”按钮 Swal.clickCancel() 以编程方式单击”Cancel”按钮 Swal.getInput() 获取输入DOM节点，此方法适用于输入参数. Swal.disableInput() 禁用输入。禁用的输入元素不可用且不可单击。 Swal.enableInput() 启用输入。 Swal.showValidationMessage(error) 显示验证消息DOM节点。 Swal.resetValidationMessage() 隐藏验证消息DOM节点。 Swal.getValidationMessage() 获取验证消息DOM节点。 Swal.queue([Array]) 提供SweetAlert2参数数组以显示多个模态，一个模态接一个。请参阅用法事例 Swal.getQueueStep() 获取队列中当前模态的索引。如果没有活动队列，则返回 null Swal.insertQueueStep() 将模态插入队列，您可以使用第二个参数指定模态定位。默认情况下，模式将添加到队列的末尾。 Swal.deleteQueueStep(index) 从队列中删除index处的模态。 Swal.getProgressSteps() 进步步骤吸气剂。 Swal.setProgressSteps([]) 进度步骤设定器。 Swal.showProgressSteps() 显示进度步骤。 Swal.hideProgressSteps() 隐藏进度步骤。 Swal.isValidParameter(param) 确定参数名称是否有效。 Swal.isUpdatableParameter(param) 确定参数名称是否对Swal.update()方法有效。 今天只有一天周末时间不用补课，再来复习复习这个前端框架！"},{"title":"ES6.0学习","date":"2022-05-06T06:50:26.000Z","url":"/2022/05/06/ES6-0%E5%AD%A6%E4%B9%A0/","tags":[["es6","/tags/es6/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"],["es6","/categories/%E5%89%8D%E7%AB%AF/es6/"]],"content":"一、简介ES6， 全称 ECMAScript 6.0 ，是 JavaScript 的下一个版本标准，2015.06 发版。 ES6 主要是为了解决 ES5 的先天不足，比如 JavaScript 里并没有类的概念。 二、ES6 的目标与愿景 成为更好编写的开发语言有以下目标。 适应更复杂的应用；实现代码库之间的共享；不断迭代维护新版本。 三、ES6 环境目前各大浏览器基本上都支持 ES6 的新特性，其中 Chrome 和 Firefox 浏览器对 ES6 新特性最友好，IE7~11 基本不支持 ES6。 四、ES6基础４.1 let命令ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 块级作用域在一些情况下，可以避免内层变量覆盖外层变量。 Let不存在变量提升 控制台的输出结果： ​ 上面代码中，变量t1用var命令声明，会发生变量提升，即脚本开始运行时，变量t1已经存在了，但是没有值，所以会输出undefined。 ​ 变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。 因此，使用let声明变量，极大的消除了代码的潜在bug的隐患。 Let暂时性死区: 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。 4.2 const 命令const声明一个只读的常量。一旦声明，常量的值就不能改变 上面代码表明改变常量的值会报TypeError: Assignment to constant variable的错。 4.3 模板字符串 注意：ES6模板字符串中必须要使用反引号。 4.4 rest参数ES6 引入 rest 参数（形式为“…变量名”），用于获取函数的多余参数。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 上面代码的add函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。rest 参数中的变量代表一个数组，所以数组特有的方法都可以用于这个变量。 4.5 箭头函数ES6允许使用“箭头”（&#x3D;&gt;）定义函数： 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分 如果只有一个参数，那么圆括号就可以省略了 如何函数体中的代码只有一句，那么大括号可以省略 如果函数体中的代码只有一个return语句，那么return关键词也必须省略 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。 箭头函数有几个使用注意点。 函数体内的this对象。函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。或者说：箭头函数当方法使用时没有定义this绑定，而是捕获所在上下文的 this ，作为自己的 this 。 注意： 箭头函数的this永远指向其上下文的 this。 普通函数的this指向调用它的那个对象。 不可以当作构造函数。也就是说，不可以使用new命令，否则会抛出一个错误。 不可以使用arguments对象。该对象在函数体内不存在。如果要用，可以用Rest参数代替。 箭头函数的一个用处是简化回调函数 简写简单说就是省略掉function，直接写（），或者不写；大括号可变箭头 &#x3D;&gt; , 函数体只有一条可以直接写，有return就省略 rest参数与箭头函数结合 五、ES6 类（Class）​ ES6提供了更接近面向对象（注意：javascript本质上是基于对象的语言）语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。 ​ 新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。 上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。也就是说，ES5的构造函数Point，对应ES6的Point类的构造方法。 Point类除了构造方法，还定义了一个toString方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。 注意：生成类的实例对象的写法，要使用new命令。如果忘记加上new，像ES5函数那样调用Class，将会报错。 ​ ……….. 六、ES6模块化编程6.1 ES6模块化实现​ 模块功能主要由两个命令构成：export和import。 ​ export命令用于规定模块的对外接口 。 ​ import命令用于输入其他模块提供的功能。 1. export 命令 在export命令后面，使用大括号指定所要输出的一组变量。 export命令除了输出变量，还可以输出函数、类（class）。 2. import命令 使用export命令定义模块对外接口后，其他 JS 文件就可以通过import命令加载这个模块。 ​ 上面代码的import命令，用于加载module1.js文件，并从中输入变量。import命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（ module1.js）对外接口的名称相同。 import命令可以使用as关键字，将输入的变量重命名。 import命令具有提升效果，会提升到整个模块的头部，首先执行 上面的代码不会报错，因为import的执行早于foo的调用。这种行为的本质是，import命令是编译阶段执行的，在代码运行之前。 import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。 如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次 import语句是 Singleton 模式 上面代码中，虽然foo和bar在两个语句中加载，但是它们对应的是同一个my_module实例。也就是说，import语句是 Singleton 模式。 3. 模块的整体加载​ 除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。 "},{"title":"mybatis入门","date":"2022-05-06T06:38:49.000Z","url":"/2022/05/06/mybatis%E5%85%A5%E9%97%A8/","tags":[["mybatis","/tags/mybatis/"]],"categories":[["mybatis","/categories/mybatis/"]],"content":"注：基于Mysql8版本 目录结构 jdbc.properties log4j日志配置 log4j.properties 注：以上是控制台输出日志，注释的为文件日志 mybatis-config.xml mybatis配置文件 工具类 MybatisUtils.java 创建实体类 Book.java 数据库表 book_info 插入数据sql语句： sql语句展开 创建接口 xml方式实现：BookDao.xml映射文件（只示例了其中一个方法， 另一个使用了注解) 测试： 运行结果： 注解方式实现：创建实体类 Emp.java 接口上通过注解编写sql 测试 测试结果： "},{"title":"数据层层获取数据id执行增删查改（踩坑）","date":"2022-05-05T16:55:22.000Z","url":"/2022/05/06/controller%E5%B1%82%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AEid%E6%89%A7%E8%A1%8C%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9%E8%B8%A9%E5%9D%91/","tags":[["javaweb","/tags/javaweb/"]],"categories":[["javaweb","/categories/javaweb/"]],"content":"去掉获取的字符串参数的两侧空白字符或其它字符，再进行整型转化即可成功！！注：单纯的写Integer.parseInt(request.getParameter(“id”)容易出错，总会面对String型数据转化 int 类型失败的问题 “ int id &#x3D; Integer.parseInt(request.getParameter(id”).trim()); "},{"title":"json与字符串之间的转换","date":"2022-05-05T16:39:38.000Z","url":"/2022/05/06/json%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/","categories":[["javaweb","/categories/javaweb/"]],"content":"javaScript中内置了一个JSON对象，可以用来进行json与字符串之间的转换 json转换成字符串：使用JSON.stringify() 字符串转换成json：使用JSON.parse() java对象转化为json格式字符串数据返回到前端页面JsonModel.java JsonUtil.java controller层返回json数据 —— servlet测试 "},{"title":"jdbc - 可变参数的通用增删查改","date":"2022-05-05T16:18:52.000Z","url":"/2022/05/06/jdbc-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%9A%84%E9%80%9A%E7%94%A8%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9/","tags":[["javaweb","/tags/javaweb/"]],"categories":[["javaweb","/categories/javaweb/"]],"content":"通用的查询修改方法，减少写重复的代码"},{"title":"javaweb-登录验证功能","date":"2022-05-02T10:27:54.000Z","url":"/2022/05/02/javaweb-%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81%E5%8A%9F%E8%83%BD/","categories":[["javaweb","/categories/javaweb/"]],"content":"学习记录 MySQL数据库表里，我将管理员跟用户都放一张表里，通过表里的status字段进行权限验证，为1是管理员，0为用户（int）。 登录处理LoginController.jsp： 下拉列表（后台获取name里的参数）： 获取下拉列表的name参数 控制层可以根据下拉列表进行登录验证（选择登录后台或者前台） "},{"title":"bootstrapTable+模态框+显示表格数据的问题","date":"2022-05-02T09:10:03.000Z","url":"/2022/05/02/bootstrapTable-%E6%A8%A1%E6%80%81%E6%A1%86-%E6%98%BE%E7%A4%BA%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE%E7%9A%84%E9%97%AE%E9%A2%98/","tags":[["bootstrap-table","/tags/bootstrap-table/"]],"categories":[["前端框架","/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"],["bootstrap-table","/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/bootstrap-table/"]],"content":"在线链接： 在我们的数据表格里每行对应的编辑按钮，当我们点击后，会弹出对应行的数据，并可以进行修改数据并提交。 测试结果如下： 对应代码： &#x2F;&#x2F; getData方法获取全部页面数据后，将data转为json对象，使用index当前行号作为下标获取对应数据 data_json的结果类型——每一行数据对应一个object： data_json : [object Object],[object Object],[object Object],[object Object],[object Object],[object Object] var data &#x3D; JSON.stringify($(“#exampleTableEvents”).bootstrapTable(‘getData’)) ： 转化为json格式数据 &#x2F;&#x2F; 删除用户 编辑用户信息 —— 模态框动态显示表格数据: bootstrap-table（html骨架）: "},{"title":"fastjson导包错误500","date":"2022-05-02T07:29:51.000Z","url":"/2022/05/02/fastjson%E5%AF%BC%E5%8C%85%E9%94%99%E8%AF%AF500/","tags":[["500","/tags/500/"]],"categories":[["报错信息合集","/categories/%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF%E5%90%88%E9%9B%86/"]],"content":"报错信息：今天使用fastjson 的TypeReference 进行反序列化的时候出现了这个错误,说是找不到类,但是实际上我是添加了相关jar包的。 解决方法就是, 将你的jar包放入项目自带的lib文件夹里就OK了 HTTP状态 500 - 内部服务器错误 类型 异常报告 消息 Servlet执行抛出一个异常 描述 服务器遇到一个意外的情况，阻止它完成请求。 例外情况 根本原因。 ):注意 主要问题的全部 stack 信息可以在 server logs 里查看 Apache Tomcat&#x2F;9.0.55"},{"title":"bootstrap-table使用","date":"2022-04-28T12:14:30.000Z","url":"/2022/04/28/bootstrap-table%E4%BD%BF%E7%94%A8/","tags":[["bootstrap-table","/tags/bootstrap-table/"]],"categories":[["前端框架","/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"],["bootstrap-table","/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/bootstrap-table/"]],"content":"在线链接 同时，还需要用户bootstrap的css和js文件，否则 bootstrap-table的按钮显示不全（bootstrap4版本不兼容） 点击列名获取一整行的数据换句话说就是根据唯一的id或者其他属性，获取该行的数据。 首先通过表格的id绑定一个唯一的列字段属性名（不是title后面的，是field后面的属性名）。这里我们指定id为唯一列字段，因为这个id是数据库中的自增[主键]，不会重复。 columns属性是设置显示数据字段内容，其中field属性值需要和实体类对应。 注：formaterProcess(value, rows) ： 其中参数value表示field对应实体类中的值，row为当前行的数据，（如果有第三个参数，则为当前行的索引）。 测试结果： "},{"title":"springmvc-异常处理（待更新）","date":"2022-04-26T10:59:07.000Z","url":"/2022/04/26/springmvc-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","tags":[["Spring MVC","/tags/Spring-MVC/"]],"categories":[["Spring","/categories/Spring/"],["Spring MVC学习","/categories/Spring/Spring-MVC%E5%AD%A6%E4%B9%A0/"]]},{"title":"springmvc7 - JSON","date":"2022-04-26T10:29:58.000Z","url":"/2022/04/26/springmvc7-JSON/","tags":[["springboot2","/tags/springboot2/"]],"categories":[["springboot2","/categories/springboot2/"],["springboot2入门","/categories/springboot2/springboot2%E5%85%A5%E9%97%A8/"]],"content":"一、各种Date之间的转换方法实体类日期字段： new Date() 的结果： birth： “2022-04-26T11:00:29.961+00:00” 问题： 这个时间格式并不是我想要的，想调整为yyyy-MM-dd HH:mm:ss这种常见格式返回到前端。 解决方法： 如下的各种Date之间的转换方法 这里我选用： 输出结果： birth： “2022-04-26 20:13:40” 即可成功解决！ 注： mysql数据库时间用datetime类型可以精确到秒， date类型只到年月日。 二、注解解析1. @JsonFormat： 用法 ：为在属性值上 @JsonFormat(pattern&#x3D;”yyyy-MM-dd”,timezone&#x3D;”GMT+8”)，如果直接使用 @JsonFormat(pattern&#x3D;”yyyy-MM-dd”)就会出现相差8个小时的情况，因为我们是东八区（北京时间）。所以我们在格式化的时候要指定时区（timezone ） 2.@JsonIgnore： 此注解用于属性或者方法上（最好是属性上），用来完全忽略被注解的字段和方法对应的属性，即便这个字段或方法可以被自动检测到或者还有其他的注解，一般标记在属性或者方法上，返回的json数据即不包含该属性。 3.@JsonProperty ： 此注解用于属性上，作用是把该属性的名称序列化为另外一个名称。 对属性名称重命名，比如在很多场景下Java对象的属性是按照规范的驼峰书写，但在数据库设计时使用的是下划线连接方式，此处在进行映射的时候就可以使用该注解。 如把实体类的trueName属性序列化为name，@JsonProperty(“name”)。 感觉这个注解的作用是： 前端传参数过来的时候，使用这个注解，可以获取到前端与注解中同名的属性 后端处理好结果后，返回给前端的属性名也不以实体类属性名为准，而以注解中的属性名为准 "},{"title":"Swagger2学习","date":"2022-04-25T11:42:35.000Z","url":"/2022/04/25/Swagger2%E5%AD%A6%E4%B9%A0/","tags":[["springboot2","/tags/springboot2/"]],"categories":[["springboot2","/categories/springboot2/"],["springboot2入门","/categories/springboot2/springboot2%E5%85%A5%E9%97%A8/"]],"content":"springboot 2.6 版本以上的要在配置文件(yml&#x2F; properties)里添加下面的配置信息 一、常用注解Swagger的所有注解定义在io.swagger.annotations包下 下面列一些经常用到的，未列举出来的可以另行查阅说明： Swagger注解 简单说明 @Api(tags &#x3D; “xxx模块说明”) 作用在模块类上 @ApiOperation(“xxx接口说明”) 作用在接口方法上 @ApiModel(“xxxPOJO说明”) 作用在模型类上：如VO、BO @ApiModelProperty(value &#x3D; “xxx属性说明”,hidden &#x3D; true) 作用在类方法和属性上，hidden设置为true可以隐藏该属性 @ApiParam(“xxx参数说明”) 作用在参数、方法和字段上，类似@ApiModelProperty 二、 依赖 三、 配置类SwaggerConfig 四、 实体配置1、新建一个实体类： 2 、只要这个实体在请求接口的返回值上（即使是泛型），都能映射到实体项中： 注：并不是因为@ApiModel这个注解让实体显示在这里了，而是只要出现在接口方法的返回值上的实体都会显示在这里，而@ApiModel和@ApiModelProperty这两个注解只是为实体添加注释的。 @ApiModel为类添加注释 @ApiModelProperty为类属性添加注释 我们也可以给请求的接口配置一些注释 这样的话，可以给一些比较难理解的属性或者接口，增加一些配置信息，让人更容易阅读！ 相较于传统的Postman或Curl方式测试接口，使用swagger简直就是傻瓜式操作，不需要额外说明文档(写得好本身就是文档)而且更不容易出错，只需要录入数据然后点击Execute，如果再配合自动化框架，可以说基本就不需要人为操作了。 缺点：在正式环境要记得关闭Swagger，一来出于安全考虑二来也可以节省运行时内存。 重启项目，访问测试  看下效果； 五、拓展：其他皮肤我们可以导入不同的包实现不同的皮肤定义： 1、默认的 访问  2、bootstrap-ui 访问  3、Layui-ui 访问  4、mg-ui 访问  "},{"title":"AOP实现操作日志记录","date":"2022-04-24T13:21:50.000Z","url":"/2022/04/24/AOP%E5%AE%9E%E7%8E%B0%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/","tags":[["springboot2","/tags/springboot2/"]],"categories":[["springboot2","/categories/springboot2/"],["springboot2入门","/categories/springboot2/springboot2%E5%85%A5%E9%97%A8/"]]},{"title":"Slf4j+logback日志使用（未完待续）","date":"2022-04-24T12:32:22.000Z","url":"/2022/04/24/springboot%E6%97%A5%E5%BF%97%E4%BD%BF%E7%94%A8/","tags":[["springboot2","/tags/springboot2/"]],"categories":[["springboot2","/categories/springboot2/"],["springboot2入门","/categories/springboot2/springboot2%E5%85%A5%E9%97%A8/"]],"content":"​ 日志，通常不会在需求阶段作为一个功能单独提出来，也不会在产品方案中看到它的细节。但是，这丝毫不影响它在任何一个系统中的重要的地位。 ​ 为了保证服务的高可用，发现问题一定要即使，解决问题一定要迅速，所以生产环境一旦出现问题，预警系统就会通过邮件、短信甚至电话的方式实施多维轰炸模式，确保相关负责人不错过每一个可能的bug。 ​ 预警系统判断疑似bug大部分源于日志。比如某个微服务接口由于各种原因导致频繁调用出错，此时调用端会捕获这样的异常并打印ERROR级别的日志，当该错误日志达到一定次数出现的时候，就会触发报警。 日志Log默认格式Spring Boot 的默认日志输出类似于以下示例(springboot运行时控制台的输出)： 详细介绍： 日期和时间：毫秒精度，易于排序。 日志级别：ERROR、WARN、INFO、DEBUG 或 TRACE。 进程标识。 A — 分隔符来区分实际日志消息的开始。 线程名称：括在方括号中（可能会被截断以用于控制台输出）。 记录器名称：这通常是源类名称（通常缩写）。 日志消息。 日志级别大小：TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL ，且级别是逐渐提供，如果日志级别设置为INFO，则意味TRACE和DEBUG级别的日志都看不到。如果这里设置为WARN，INFO级别的日志都不显示。 Spring Boot默认日志系统Spring Boot默认使用LogBack日志系统，如果不需要更改为其他日志系统如Log4j2等，则无需多余的配置，LogBack默认将日志打印到控制台上。 如何将日志信息存储到文件在本机环境，我们习惯在控制台看日志，但是线上我们还是要通过将日志信息保存到日志文件中，查询日志文件即可。 摘抄记录："},{"title":"springboot热部署","date":"2022-04-24T11:47:19.000Z","url":"/2022/04/24/springboot%E7%83%AD%E9%83%A8%E7%BD%B2/","tags":[["springboot2","/tags/springboot2/"]],"categories":[["springboot2","/categories/springboot2/"],["springboot2入门","/categories/springboot2/springboot2%E5%85%A5%E9%97%A8/"]],"content":"第一步：导入pom依赖 第二步： 在IDEA中的配置、 ​ 较新的版本是在setting -》 Advanced Settings -》 勾选compiler类型的框中的选项 完成这两步之后即可完成热部署，在类文件修改代码后，可以花几秒的时间摸鱼再刷新页面，即可出现新数据。"},{"title":"private static final long serialVersionUID=1L什么意思","date":"2022-04-24T10:12:42.000Z","url":"/2022/04/24/private-static-final-long-serialVersionUID-1L%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/","tags":[["springboot2","/tags/springboot2/"]],"categories":[["springboot2","/categories/springboot2/"],["springboot2入门","/categories/springboot2/springboot2%E5%85%A5%E9%97%A8/"]],"content":"serialVersionUID作用： 相当于java类的身份证。主要用于版本控制。 serialVersionUID作用是序列化时保持版本的兼容性，即在版本升级时反序列化仍保持对象的唯一性。 序列化时为了保持版本的兼容性，即在版本升级时反序列化仍保持对象的唯一性。 有两种生成方式： 一个是默认的1L，比如：private static final long serialVersionUID &#x3D; 1L; 一个是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段，比如： private static final long serialVersionUID &#x3D; xxxxL;"},{"title":"数据校验（未完待续）","date":"2022-04-24T09:29:13.000Z","url":"/2022/04/24/%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/","tags":[["springboot2","/tags/springboot2/"]],"categories":[["springboot2","/categories/springboot2/"],["springboot2入门","/categories/springboot2/springboot2%E5%85%A5%E9%97%A8/"]],"content":"一、JSR - 303 ​ JSR 是 Java Specification Requests 的缩写，即 Java 规范提案。 存在各种各样的 JSR，简单的理解为 JSR 是一种 Java 标准。 JSR 303 就是数据检验的一个标准（Bean Validation (JSR 303)）。 二、为什么使用JSR-303​ 处理一段业务逻辑，首先要确保数据输入的正确性，所以需要先对数据进行检查，保证数据在语义上的正确性，再根据数据进行下一步的处理。 前端可以通过 js 程序校验数据是否合法，后端同样也需要进行校验。而后端最简单的实现就是直接在业务方法中对数据进行处理，但是不同的业务方法可能会出现同样的校验操作，这样就出现了数据的冗余。为了解决这个情况，JSR 303 出现了。 JSR-303 使用 Bean Validation，即在 Bean 上添加相应的注解，去实现数据校验。这样在执行业务方法前，都会根据注解对数据进行校验，从而减少自定义的校验逻辑，减少代码冗余。 ​ (参考：) 导入依赖： "},{"title":"注解@ConfigurationProperties使用方法","date":"2022-04-23T15:51:14.000Z","url":"/2022/04/23/%E6%B3%A8%E8%A7%A3-ConfigurationProperties%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","tags":[["springboot2","/tags/springboot2/"]],"categories":[["springboot2","/categories/springboot2/"],["springboot2入门","/categories/springboot2/springboot2%E5%85%A5%E9%97%A8/"]],"content":"注意：根据 Spring Boot 松散绑定，类的属性名称必须与外部属性的名称匹配 以上四种命名可以自动绑定bean属性（properties配置文件也可用该注解） 激活 @ConfigurationProperties​ 我们除了在实体类上标注注解@ConfigurationProperties，还需要让spring容器知道它的存在，以便将其加载到应用程序上下文中。 ​ 所以，我们可以通过添加 @Component 注解让 Component Scan 扫描到 ​ ${user.userName}只支持属性的调用，不支持运算 测试yml配置文件： Person实体类： Address实体类： 用法: 输出 JSON格式： 总结 @ConfigurationProperties 和 @value 有着相同的功能,但是 @ConfigurationProperties的写法更为方便 @ConfigurationProperties 的 POJO类的命名比较严格,因为它必须和prefix的后缀名要一致, 不然值会绑定不上, 特殊的后缀名是“driver-class-name”这种带横杠的情况,在POJO里面的命名规则是 下划线转驼峰 就可以绑定成功，所以就是 “driverClassName” "},{"title":"springboot的相关注解","date":"2022-04-21T14:29:45.000Z","url":"/2022/04/21/springboot%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/","tags":[["springboot2","/tags/springboot2/"]],"categories":[["springboot2","/categories/springboot2/"],["springboot2入门","/categories/springboot2/springboot2%E5%85%A5%E9%97%A8/"]],"content":"一、 Java注解的介绍​ JRE 的库包 java.lang.annotation 中代码包括注释相关的接口、类等内容。接口 java.lang.annotation 是所有自定义注解自动继承的接口，不需要定义时指定。 ​ 注解是一系列元数据，它利用元数据来解释、说明程序代码（被注解的对象）。 二、Java的元注解元注解是加到注解上的注解，它的目的是解释、说明其他普通注解。 ​ 元注解有@Retention、@Taget、@Inherited、@Documented、@intertface五种。 2.1 @Taget​ @Taget该注解的作用是告诉 Java 将自定义的注解用于什么地方，比如类、方法、构造器、变量上等，它的值是一个枚举类型，有如下属性值。 ElementType.CONSTRUCTOR：用于描述构造器。 ElementType.FIELD：用于描述成员变量、对象、属性（ 包括enum实例 ）。 ElementType.LOCAL_VARIABLE：用于描述局部变量。 ElementType.METHOD：用于描述方法。 ElementType.PACKAGE：用于描述包。 ElementType.PARAMETER：用于描述参数。 ElementType.TYPE：用于描述类、接口（ 包括注解类型 ）或 enum 声明。 2.2 @Retention该注解用于说明自定义注解的生命周期，在注解中有三个生命周期。 RetentionPolicy.RUNTIME：始终不会丢弃， 运行期也保留读注解，可以使用反射机制读取该注解的信息。 自定义的注解通常使用这种方式。 RetentionPolicy.CLASS：类加载时丢弃，默认使用这种方式。 RetentionPolicy.SOURCE：编译阶段丢弃，自定义注解在编译结束之后就不再有意义，所以它们不会写入字节码。@Overide、@SuppressWarnings 都属于这类注解。 2.3 @Inherited​ 被@Inherited注解过的注解作用于父类后，子类会自动继承父类的注解。 2.4 @Documented该注解表示是否将注解信息添加在 Java 文档中。 2.5 @intertface该注解用来声明一个注解， 其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（ 返回值类型只能是基本类型、Class、String、enum ）。可以通过 default 来声明参数的默认值。 定义注解格式的代码：public @interface 注解名 {定义体} 三、常用的注解​ @RequestMapping：为类或者方法指定一个映射路径，可以通过指定的路径来访问对应的类或者方法。 ​ @PathVariable： 主要用来获取单一的URI参数。 ​ @RequestBody：把请求报文中的正文自动转换成绑定给方法参数的变量字符串。（JSON格式返回数据） ​ @Param： 表示对参数的解释，一般写在注释里。 ​ @JoinTable：表示Java类和数据库表的映射关系，也可以标识列的映射，主键的映射等。 ​ @Transational： Spring事务管理的注解。被它标注的方法或类自动被注册成事务，接受spring容器的管理。 ​ @Syschronized: 表示实现Java同步机制，用它作注解相当于加同步锁。 ​ @Cacheable： 表明一个方法的返回值应该被缓存，注解@CacheFlush声明一个方法是清空缓存的触发器，这两个注解要配合缓存器使用。 ​ @Conditional：根据满足某一特定条件创建一个特定的bean。 ​ @ModelAttribute：声明在属性上，表示该属性来源于model里queryBean，并保存到model里。该注解声明在方法上，表示该方法的返回值被保存到model里。 四、JPA注解​ @Entity: 表明被标注的对象是个实体类 ​ @Table(name&#x3D;””) : 指出实体对应的表名； ​ 这两个注解一般一起使用。但是如果表名和实体类名相同，则@Table可以省略。 ​ 进行开发项目时，经常会用到将实体类映射到数据库表的操作。有时需要映射的几个实体类有共同的属性，这时可以把这些属性抽象成一个父类，然后各个实体类继承这个父类。可以使用@MappedSuperclass注解标注父类，它不会映射到数据库表，但子类在映射时会自动扫描父类的映射属性，并将这些属性添加到子类对应的数据库表中。使用@MappedSuperclass注解后不能再有@Entity或者@Table注解。 ​ @Column：标识实体类中属性与数据表中的字段的对应关系。如果注解@Column的字段名与列名相同，则可以省略。 该注解有10个属性，且均为可选属性。内容略。。。 ​ @Id: 用于声明一个实体类的属性映射为数据库的主键列。 ​ @JoinColumn(name&#x3D;”loginId”)：表示一张表有指向另一个表的外键。 五、异常处理​ @ControllerAdvice包含@Component，可以被扫描到，统一异常处理。 ​ @ExceptionHandler(Exception.class)：用在方法上面表示遇到这个异常就执行所标注的方法"},{"title":"Springboot简介","date":"2022-04-21T13:14:25.000Z","url":"/2022/04/21/Springboot%E5%85%A5%E9%97%A8/","tags":[["springboot2","/tags/springboot2/"]],"categories":[["springboot2","/categories/springboot2/"],["springboot2入门","/categories/springboot2/springboot2%E5%85%A5%E9%97%A8/"]],"content":"使用2.0.0以上版本的springboot需要安装jdk1.8以上的版本！！ 一、springboot2的核心模块​ springboot中提供了许多的starter模块，为开发者提供了许多“一站式”服务。通过在项目添加对应框架的starter依赖，可以免去到处寻找依赖包的烦恼。只要加一个依赖项目就可以运行，这就是starter的作用。Springboot官方提供的starter模块，一般命名“spring-boot-starter-*”，其中 “ * ”代表要使用的应用。 spring Boot应用启动器基本的一共有44种，具体如下 SpringBoot - starter 有哪些模块 二、springboot的启动类入口分析​ @SpringBootApplication : 是Sprnig Boot项目的核心注解，目的是开启自动配置。 ​ 1. @SpringBootApplication注解用于启动springboot。 ​ 2. @SpringBootApplication注解与@Configuration，@EnableAutoConfiguration，@ComponentScan等三个注解完全等价（前者是有后者三个注解合并而来的） ​ 三、深入探索 SpringApplication 执行流程略……. 四、IDEA创建项目之后的目录结果 src&#x2F;main&#x2F;java 目录下包括主程序入口类，可用来启动程序；及所需的接口 、类文件。 src&#x2F;main&#x2F;resources 是资源目录，存放一些配置信息。由于开发的web应用，因此在src&#x2F;main&#x2F;resources下产生了static子目录和template子目录，statis子目录存放静态资源（如css，js等文件）；templa子目录主要用于存放web页面动态视图文件。 pom.xml是项目管理的重要文件。 五、项目属性配置​ 1. 在springboot中主要通过application.properties文件、application.yml文件实现对属性的配置。 ​ 2. 这两种文件的格式不同，但内容对应、作用相同。 ​ 3. 配置文件的默认执行顺序是： ​ 项目根目录下的config子目录 -&gt; 项目根目录 -&gt; 项目classpath子目录下的config子目录 -&gt; 项目classpath子目录。 六、注解 @EnableAutoConfiguration Annotation：这个注解告诉 Spring Boot 根据你添加的 jar 依赖来“猜测”你想如何配置 Spring。由于 spring-boot-starter-web 添加了 Tomcat 和 Spring MVC，因此自动配置，假定您正在开发 Web 应用程序并会相应地设置 Spring。 七、The “main” Method ​ 我们应用程序的最后一部分是main 方法。这只是遵循应用程序入口点的 Java 约定的标准方法。 我们的 main 方法通过调用 run 委托给 Spring Boot 的SpringApplication 类。SpringApplication 引导我们的应用程序，启动 Spring，然后启动自动配置的 Tomcat Web 服务器。我们需要将 Example.class 作为参数传递给 run 方法来告诉 SpringApplication 哪个是主要的 Spring 组件。 args 数组也被传递以公开任何命令行参数。"},{"title":"jsp动态获取数据库数据并生成缩略图","date":"2022-04-09T05:36:44.000Z","url":"/2022/04/09/jsp%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E5%B9%B6%E7%94%9F%E6%88%90%E7%BC%A9%E7%95%A5%E5%9B%BE/","tags":[["jsp","/tags/jsp/"]],"categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"],["jsp","/categories/%E5%89%8D%E7%AB%AF/jsp/"]],"content":"一、Controller层将数据存到session中 注意：response.getWriter().println(JsonUtil.toJsonString(pageBean)); 是ajax处理的 二、jsp代码 注：获取值用get（）方法…… 三、测试结果："},{"title":"ajax请求数据库图片数据回显","date":"2022-04-07T15:33:10.000Z","url":"/2022/04/07/ajax%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%E5%9B%9E%E6%98%BE/","categories":[["前端","/categories/%E5%89%8D%E7%AB%AF/"],["ajax","/categories/%E5%89%8D%E7%AB%AF/ajax/"]],"content":"一、jqeury用字符串拼接的ID选择器使用方式注： 单纯这样写，会用最后的图片路径，覆盖原来的图片路径（遍历每一个img都会执行6次赋值操作，以最后一个数据为准） 解决方法： 二、ajax请求 三、源码： 三、result： "},{"title":"SpringMVC拦截器","date":"2022-03-24T14:18:46.000Z","url":"/2022/03/24/SpringMVC%E6%8B%A6%E6%88%AA%E5%99%A8/","tags":[["Spring MVC","/tags/Spring-MVC/"]],"categories":[["Spring","/categories/Spring/"],["Spring MVC学习","/categories/Spring/Spring-MVC%E5%AD%A6%E4%B9%A0/"]],"content":"​ 早期MVC框架将一些通用操作写死在核心控制器中，致使框架灵活性不足、可扩展性降低。 Spring将预处理与后处理功能放到多个拦截器中实现，拦截器可自由选择和组合，增强了灵活性，有利于系统的解耦。SpringMVC的拦截器类似于Servlet中的过滤器Filter，用于对处理器进行预处理和后处理。 1、创建SpringMVC拦截器创建 SpringMVC 拦截器，只需要实现 HandlerInterceptor 接口即可。 接口中有三个方法需要实现： preHandle：该方法在 controller 执行前执行，可以实现对数据的预处理。 如果方法返回 true ，则继续调用下一个资源。否则不在继续调用。 postHandle：该方法在处理器执行后，生成视图前执行。这里有机会修改视图层数据。 afterCompletion：最后执行，通常用于记录日志，释放资源，处理异常。 2、配置SpringMVC拦截器 3、测试 测试结果： (如果preHandle方法返回值为false，则目标方法不会再执行)"},{"title":"项目统一异常处理(未完待续...)","date":"2022-03-24T05:35:55.000Z","url":"/2022/03/24/%E9%A1%B9%E7%9B%AE%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","tags":[["Spring MVC","/tags/Spring-MVC/"]],"categories":[["Spring","/categories/Spring/"],["Spring MVC学习","/categories/Spring/Spring-MVC%E5%AD%A6%E4%B9%A0/"]],"content":"​ 在J2EE项目的开发中，不管是对底层的数据库操作过程，还是业务层的处理过程，还是控制层的处理过程，都不可避免会遇到各种可预知的、不可预知的异常需要处理。每个过程都单独处理异常，系统的代码耦合度高，工作量大且不好统一，维护的工作量也很大。 ​ 任何程序都会有异常。无论你是做什么项目，对异常的处理都是非常有必要的，尤其是web项目，因为它一般直接面向用户，所以良好的异常处理就显得格外的重要。 ​ Java异常体系简介 ​ Java相较于其它大多数语言提供了一套非常完善的异常体系Throwable：分为Error和Exception两大分支： Error：错误，对于所有的编译时期的错误以及系统错误都是通过Error抛出的，比如NoClassDefFoundError、硬件问题等等。 Exception：异常，是更为重要的一个分支，是程序员经常打交道的。异常定义为是程序的问题，程序本身是可以处理的。异常Exception它本身还分为两大重要的分支：Checked Exception（可检查异常，如IOException）和Unchecked Exception（不可检查异常，如RuntimeException）。 Error和Exception最大的区别是：异常是可以被程序处理的，而错误是没法处理的。 ​ 错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况（比如类找不到NoClassDefFoundError） ​ 对于与数据库相关的 Spring MVC 项目，我们通常会把 事务 配置在 Service层，当数据库操作失败时让 Service 层抛出运行时异常，Spring 事物管理器就会进行回滚。 ​ 如此一来，我们的 Controller 层就不得不进行 try-catch Service 层的异常，否则会返回一些不友好的错误信息到客户端。但是，Controller 层每个方法体都写一些模板化的 try-catch 的代码，很难看也难维护，特别是还需要对 Service 层的不同异常进行不同处理的时候。 只要设计得当，就再也不用在 Controller 层进行 try-catch 了！ ​ HTTP status codes： 异常类型 状态码 MissingPathVariableException 500 ConversionNotSupportedException 500 HttpMessageNotWritableException 500 AsyncRequestTimeoutException 503 MissingServletRequestParameterException 400 ServletRequestBindingException 400 TypeMismatchException 400 HttpMessageNotReadableException 400 MethodArgumentNotValidException 400 MissingServletRequestPartException 400 BindException 400 NoHandlerFoundException 404 HttpRequestMethodNotSupportedException 405 HttpMediaTypeNotAcceptableException 406 HttpMediaTypeNotSupportedException 415 1、使用web技术​ 在还没有Spring，更无Spring Boot时，开发使用的是源生的Servlet + tomcat容器。其实它也是提供了通用的异常的处理配置方式的。 ​ 使用web技术，需要在web.xml进行配置异常代码和异常跳转页面，然后程序中出现异常时，就会自动跳转到指定的异常页面。 2、HandlerExceptionResolver异常解析器HandlerExceptionResolver接口仅有一个resolveException方法用于处理异常 resolveException方法将返回ModelAndView类型的结果，返回值有如下约定： ​ ModelAndView对象中可以包含包含响应的错误的数据和一个要转发到的错误视图。如果异常在解析器中已被处理，并且不需要返回异常视图，则可以返回一个空的ModelAndView。​ 如果异常仍未解决，则返回null，以便后面的异常解析器继续尝试解决，如果解析器链执行完毕异常仍未解决，则该异常将直接向上抛出到 Servlet 容器。 测试​ （适合前后端不分离的情况） 方法一： 自定义异常类 异常视图页面 我们自定义一个异常解析器，用于将异常信息转发到error.jsp异常视图！ 自定义异常处理器 我们准备一个Controller，分别模拟抛出SysException和其他异常！ 测试异常 结果如下： 方法二： MyExceptionResolver.java ExceptionController.java Exception01.java Exception02、Exception03同上…. 测试结果： 3 、异常解析器链​ 我们可以通过在 Spring 配置中声明多个HandlerExceptionResolver的 bean，并根据需要设置其顺序属性来形成异常解析器链。并且支持order排序，order值越大，异常解析器的在链中的位置越靠后（解析器链实际上是一个List集合）。我们通过实现Ordered接口或者使用@Order注解来确定order值，如果不配置order值，那么默认为最大值，即Integer.MAX_VALUE，也就是说在链尾部！ ​ 当抛出异常时，DispatcherServlet将会依次调用异常解析器链的每一个析器的resolveException方法，如果当前异常解析器的resolveException方法返回null，那么表示未能成功处理该异常，那么继续调用下一个异常解析器，否则，表示异常处理器成功，不会继续调用后续的解析器！ ​ 如：新建另一个异常解析器SysExceptionResolver2，它的order值为0，小于2，因此它将会被先于SysExceptionResolver调用！ ​ 如果将SysExceptionResolver2的@Order注解值改为大于2，或者去掉该注解，那么SysExceptionResolver将会先被调用： 4、@ExceptionHandler统一异常处理​ Spring提供了HandlerExceptionResolver的几个默认实现，它们具有自己的可扩展的解决异常的方式，我们完全可以直接利用这些默认实现，只需要配置对应的异常处理的方案，而无需再自定义HandlerExceptionResolver，无需自己编写完整的异常处理逻辑！ ​ ExceptionHandlerExceptionResolver通过调用在@Controller类或者@ControllerAdvice类中的具有@ExceptionHandler注解的方法来解决来自Controller方法的异常，这实际上就是一种非常常用并且简单的处理异常的方式，在目前的项目中，大多使用该方式！ "},{"title":"bootstrap-table分页","date":"2022-03-21T13:10:20.000Z","url":"/2022/03/21/bootstrap-table%E5%88%86%E9%A1%B5/","tags":[["bootstrap-table","/tags/bootstrap-table/"]],"categories":[["前端框架","/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"],["bootstrap-table","/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/bootstrap-table/"]],"content":"一、bootstrap-table客户端分页：​ 数据库查询所有的数据，在前端进行分页 ​ 直接返回List&lt;&gt; 类型的数据即可 （rows: [{},{},,]） 二、bootstrap-table服务端分页：​ 每次只查询当前页面加载所需要的那几条数据, 从数据库返回 数据要这种json格式： 代码示例： 用来接收客户端发来的分页请求（offset，pageNumber） controller层向客户端发送分页的json格式数据 controller层 dao层使用了mybatis，在接口出写好sql语句 mybatis配置文件 spring-dao.xml "},{"title":"声明式事务控制","date":"2022-03-20T10:39:05.000Z","url":"/2022/03/20/%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/","tags":[["Spring注解","/tags/Spring%E6%B3%A8%E8%A7%A3/"]],"categories":[["Spring","/categories/Spring/"],["Spring注解驱动学习","/categories/Spring/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/"]],"content":"一、什么是声明式事务控制​ Spring 的声明式事务顾名思义就是采用声明的方式来处理事务。这里所说的声明，就是指在配置文件中声明，用在 Spring 配置文件中声明式的处理事务来代替代码式的处理事务。 ​ 1. 搭建声明式事务的环境​ 对数据库进行增删改操作时，必然是要使用到事务的。因此，接下来，我们就来搭建好声明式事务的基本环境。 导入相关依赖: JdbcConfig.java配置类 ​ 配置数据源以及JdbcTemplate: ​ 1. 首先，我们得向IOC容器中注册一个c3p0数据源，那么如何做到这一点呢？很简单，先新建一个配置类，例如TxConfig，再使用@Bean注解向IOC容器中注册一个c3p0数据源，如下所示。 JdbcConfig.java配置类 然后，再向IOC容器中注册一个JdbcTemplate组件，它是Spring提供的一个简化数据库操作的工具，它能简化对数据库的增删改查操作。 注册一个JdbcTemplate组件 ​ 注意，在创建JdbcTemplate对象的时候，得把数据源传入JdbcTemplate类的有参构造器中，因为需要从数据源里面获取数据库连接。 ​ 为什么可以这样做呢？因为@Bean注解标注的方法在创建对象的时候，方法参数的值是从IOC容器中获取的，并且标注在这个方法的参数上的@Autowired注解可以省略。 ​ 这种方式就不用那么麻烦了，在JdbcTemplate类的有参构造器中调用一次dataSource()方法即可。可以看到，向IOC容器中注册一个JdbcTemplate组件时，使用的就是这种方式。 ​ 有些同学可能会有一些疑问，TxConfig配置类的dataSource()方法是向IOC容器中注册一个c3p0数据源的，该方法的逻辑也很简单，就是创建一个c3p0数据源并将其返回出去，而在向IOC容器中注册一个JdbcTemplate组件时，会在其有参构造器中调用一次dataSource()方法，那岂不是又会创建一个c3p0数据源呢？不知你会不会有这样一个疑问，反正我是有的。 ​ 其实，并不会再创建一个c3p0数据源，因为对于Spring的配置类而言，只要某个方法是给IOC容器中注册组件的，那么我们第二次调用该方法，就相当于是从IOC容器中找组件，而不是说把该方法再运行一遍。 ​ 总结一下，Spring对@Configuration注解标注的类会做特殊处理，多次调用给IOC容器中添加组件的方法，都只是从IOC容器中找组件而已。 ​ ​ 在Service组件中，使用@Transactional注解，就可以给业务方法添加事务管理。 注意： 需要事务管理的service，在方法上加上@Transactional 注解即可。 必须为public方法才行,不要捕捉异常，要让异常自动抛出，否则不能进行事务回滚。 二、声明式事务处理的作用 事务管理不侵入开发的组件。具体来说，业务逻辑对象就不会意识到正在事务管理之中，事实上也应该如此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，如果想要改变事务管理策划的话，也只需要在定义文件中重新配置即可。 在不需要事务管理的时候，只要在设定文件上修改一下，即可移去事务管理服务，无需改变代码重新编译，这样维护起来极其方便。 注意：Spring 声明式事务控制底层就是AOP。 ​ 编程式事务控制三大对象： PlatformTransactionManager TransactionDefinition TransactionStatus 三、事务传播行为@Transactional 注解中的 propagation 属性，可以设置事务传播行为。属性值为： REQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，就加入到这个事务中。这是最常见的选择。 SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行。 MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常。 REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起。 NOT_SUPPORTED：以非事务方式执行操作，如果存在事务，就把当前事务挂起。 NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。 超时时间：默认值是-1，没有超时限制。如果有，以秒为单位进行设置 是否只读：建议查询时设置为只读 ​ 接下来，我们就为Service类中的getDeptById()方法添加上事务，添加上事务以后，只要这个方法里面有任何一句代码出现了问题，那么该行代码之前执行的所有操作就都应该回滚。 ​ 如果要想为该方法添加上事务，那么就得使用@Transactional注解了。我们在该方法上标注这么一个注解，就是为了告诉Spring这个方法它是一个事务方法，这样，Spring在执行这个方法的时候，就会自动地进行事务控制。如果该方法正常执行，没出现任何问题，那么该方法中的所有操作都会生效，最终就会提交；如果该方法运行期间出现异常，那么该方法中的所有操作都会回滚。 ​ 光为getDeptById()方法加一个@Transactional注解是不行的，那我们还得做什么呢？还得在配置类上标注一个@EnableTransactionManagement注解，来开启基于注解的事务管理功能。 ​ 如果是像以前一样基于配置文件来开发，那么就得在配置文件中添加如下这样一行配置，来开启基于注解的事务管理功能。 四、声明式事务控制的实现​ 声明式事务控制明确事项： 谁是切点？ 谁是通知？ 配置切面？ 五、添加事务管理​ Spring为了支持事务管理，专门封装了事务管理对象。我们只要在Spring容器中配置这个对象，即可使用。 ​ 在Spring容器中添加事务管理的配置： xml配置文件 注解方式的配置 ​ 在主配置类上标注一个@EnableTransactionManagement注解，来开启基于注解的事务管理功能，为需要实现的方法添加上事务，那么就得使用@Transactional注解。如： "},{"title":"AOP入门","date":"2022-03-19T14:39:22.000Z","url":"/2022/03/19/AOP%E5%85%A5%E9%97%A8/","tags":[["Spring注解","/tags/Spring%E6%B3%A8%E8%A7%A3/"]],"categories":[["Spring","/categories/Spring/"],["Spring注解驱动学习","/categories/Spring/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/"]],"content":"1. Spring 的 AOP 简介1.1 什么是 AOP​ AOP 为 Aspect Oriented Programming 的缩写，意思为面向切面编程，是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 ​ AOP 是 OOP 的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 简单的说它就是把我们程序重复的代码抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码的基础上，对我们的已有方法进行增强。 ​ 1.2 AOP 的作用及其优势 作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强 优势：减少重复代码，提高开发效率，并且便于维护 1.3 AOP 的底层实现​ 实际上，AOP 的底层是通过 Spring 提供的的动态代理技术实现的。在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。 1.4 AOP 的动态代理技术动态代理是一种常用的设计模式，广泛应用于框架中，Spring框架的AOP特性就是应用动态代理实现的。 常用的动态代理技术 实现动态代理有两种形式： jdk动态代理：根据目标类接口获取代理类实现规则，生成代理对象。这个代理对象，也是目标类接口的一个实现类。 cglib动态代理：根据目标类本身获取代理类实现规则，生成代理对象。这个代理对象，也是目标类的一个子类。 （如果目标类为final，则不能使用CGLib实现动态代理） SpringAOP可以自动在jdk动态代理和CGLib动态代理之间进行切换，规则如下： 如果目标对象实现了接口，采用jdk动态代理实现aop。 如果目标对象没有实现接口，采用CGLib动态代理实现aop。 如果目标对象实现了接口，但仍然想要使用CGLIB实现aop，可以手动进行配置。 cglib动态代理： 注意： dao层不能再实现接口。 service层不能再实现接口。 1.5 AOP 相关概念 Target（目标对象）：代理的目标对象。 Proxy （代理）：一个类被 AOP 织入增强后，就产生一个结果代理类。 Joinpoint（连接点）：所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点。 Pointcut（切入点）：所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义。 Advice（通知&#x2F; 增强）：所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知。 Aspect（切面）：是切入点和通知（引介）的结合。 Weaving（织入）：是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入， 而 AspectJ 采用编译期织入和类装载期织入。 1.6 AOP 开发明确的事项1.6.1 需要编写的内容​ 1. 编写核心业务代码（目标类的目标方法） ​ 2. 编写切面类，切面类中有通知(增强功能方法) ​ 3. 在配置文件中，配置织入关系，即将哪些通知与哪些连接点进行结合 1.6.2 AOP 技术实现的内容​ Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。 1.6.3 AOP 底层使用哪种代理方式​ 在 spring 中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。 1.7 知识要点 aop：面向切面编程 aop底层实现：基于JDK的动态代理 和 基于Cglib的动态代理 aop的重点概念：* Pointcut（切入点）：被增强的方法 * Advice（通知&#x2F; 增强）：封装增强业务逻辑的方法 * Aspect（切面）：切点+通知 * Weaving（织入）：将切点与通知结合的过程 开发明确事项： 谁是切点（切点表达式配置） 谁是通知（切面类中的增强方法） 将切点和通知进行织入配置 2. 导入依赖 ​ Aspectj是一个基于java的、面向切面的AOP框架。Spring2.0之后增加了对Aspectj切点表达式的支持。而实际开发中一般都使用Aspectj方式来实现AOP。所以还要导入Aspectj相关jar包。 3. 切点表达式的写法3.1 表达式语法：​ execution([修饰符] 返回值类型 包名.类名.方法名(参数)) 访问修饰符可以省略 返回值类型、包名、类名、方法名可以使用星号* 代表任意 包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类 参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表 例如： 3.2 Spring AOP支持的切入点指示符：(1)execution:用来匹配执行方法的连接点 A:@Pointcut(“execution(* com.aijava.springcode.service..*.*(..))”) B:@Pointcut(“within(com.aijava.springcode.service.*)”) within限定匹配方法的连接点,上面的就是表示匹配service包下的任意连接点 C:@Pointcut(“this(com.aijava.springcode.service.UserService)”) this用来限定AOP代理必须是指定类型的实例，如上，指定了一个特定的实例，就是UserService D:@Pointcut(“bean(userService)”) bean也是非常常用的,bean可以指定IOC容器中的bean的名称 4. 基于注解的 AOP 开发4.1 基于注解的aop开发步骤​ ① 创建目标接口和目标类（内部有切点）​ ② 创建切面类（内部有增强方法）​ ③ 将目标类和切面类的对象创建权交给 spring​ ④ 在切面类中使用注解配置织入关系​ ⑤ 在配置文件中开启组件扫描和 AOP 的自动代理​ ⑥ 测试 4.2 使用步骤 @EnableAspectJAutoProxy(proxyTargetClass &#x3D; false)：声明自动为spring容器中那些配置@Aspect切面的bean创建代理，织入切面。开启基于注解的aop模式 @Aspect：定义切面类，切面类里定义通知 @PointCut 切入点，可以写切入点表达式，指定在哪个方法切入 JoinPoint：连接点,是一个类，配合通知使用，用于获取切入的点的信息 通知的类型： 名称 注解 说明 前置通知 @Before 用于配置前置通知。指定增强的方法在切入点方法之前执行 后置通知 @AfterReturning 用于配置后置通知。指定增强的方法在切入点方法之后执行 环绕通知 @Around 用于配置环绕通知。指定增强的方法在切入点方法之前和之后都执行 异常抛出通知 @AfterThrowing 用 用于配置异常抛出通知。指定增强的方法在出现异常时执行 最终通知 @After 用于配置最终通知。无论增强方式执行是否有异常都会执行 ​ 注： 连接点（JoinPoint 就是要织入的业务方法） ​ 在实际开发中，除了业务逻辑这个主要功能之外，还需要处理许多辅助功能。 比如：日志、异常处理、事务、输入验证、安全等等，我们将这些代码称为：方面代码。而方面代码，就是我们要抽取出来的。 下面抽取日志方面代码： @Aspect注解：定义此类为方面代码，即是一个通知。 @Before注解：定义一个前置通知。即在目标方法执行前切入此注解标注的方法。 execution() 是一个Aspect表达式，语法为：execution(返回值类型 包名.类名.方法名 (参数) 异常) 4.3 AOP底层实现Jdk代理：基于接口的代理，一定是基于接口，会生成目标对象的接口的子对象。 Cglib代理：基于类的代理，不需要基于接口，会生成目标对象的子对象。 注解@EnableAspectJAutoProxy开启代理; 如果属性proxyTargetClass默认为false, 表示使用jdk动态代理织入增强; 如果属性proxyTargetClass设置为true，表示使用Cglib动态代理技术织入增强; 如果属性proxyTargetClass设置为false，但是目标类没有声明接口， Spring aop还是会使用Cglib动态代理，也就是说非接口的类要生成代理都用Cglib。 4.4 快速入门​ 通过注解**@Pointcut*定义切点，pointCut*()只是一个标识，无所谓是什么， ​ 方法中内容本身也是空的，使用该切点的地方直接通过标识 pointCut()引用切点表达式。 Operator.java 注意： 如果配置了环绕通知，那么业务方法的执行将在环绕通知中的obj &#x3D; pjp.proceed();这段代码时开始执行。此时要注意：如果环绕通知方法不写返回值，或者obj &#x3D; pjp.proceed()这段代码如果不取得返回值，那么返回通知也不能取得返回值。 有了环绕通知，异常通知也将失去作用。 实际上，如果要配置环绕通知，那么其他通知就失去意义了。因为在环绕通知中，也可以在方法执行前、执行后做方面代码，包括获取返回值、做异常处理等。 UserService.java 测试 注解版的配置文件，相当于xml 运行结果： 5. 为什么用aop​ 1. 就是为了方便，看一个国外很有名的大师说，编程的人都是“懒人”，因为他把自己做的事情都让程序做了。用了aop能让你少写很多代码，这点就够充分了吧 2. 就是为了更清晰的逻辑，可以让你的业务逻辑去关注自己本身的业务，而不去想一些其他的事情，这些其他的事情包括：安全，事物，日志等。 3. 那些AOP的术语 初看这么多术语，一下子都不好接受，慢慢来，很快就会搞懂。 1.通知（Advice） 就是你想要的功能，也就是上面说的 安全，事物，日志等。你给先定义好把，然后在想用的地方用一下。 2.连接点（JoinPoint） 这个更好解释了，就是spring允许你使用通知的地方，那可真就多了，基本每个方法的前，后（两者都有也行），或抛出异常时都可以是连接点，spring只支持方法连接点.其他如aspectJ还可以让你在构造器或属性注入时都行，不过那不是咱关注的，只要记住，和方法有关的前前后后（抛出异常），都是连接点。 3.切入点（Pointcut） 上面说的连接点的基础上，来定义切入点，你的一个类里，有15个方法，那就有几十个连接点了对把，但是你并不想在所有方法附近都使用通知（使用叫织入，以后再说），你只想让其中的几个，在调用这几个方法之前，之后或者抛出异常时干点什么，那么就用切点来定义这几个方法，让切点来筛选连接点，选中那几个你想要的方法。 4.切面（Aspect） 切面是通知和切入点的结合。现在发现了吧，没连接点什么事情，连接点就是为了让你好理解切点，搞出来的，明白这个概念就行了。通知说明了干什么和什么时候干（什么时候通过方法名中的before,after，around等就能知道），而切入点说明了在哪干（指定到底是哪个方法），这就是一个完整的切面定义。 5.引入（introduction） 允许我们向现有的类添加新方法属性。这不就是把切面（也就是新方法属性：通知定义的）用到目标类中吗 6.目标（target） 引入中所提到的目标类，也就是要被通知的对象，也就是真正的业务逻辑，他可以在毫不知情的情况下，被咱们织入切面。而自己专注于业务本身的逻辑。 7.代理(proxy) 怎么实现整套aop机制的，都是通过代理，这个一会给细说。 8.织入(weaving) 把切面应用到目标对象来创建新的代理对象的过程。有3种方式，spring采用的是运行时，为什么是运行时，后面解释。 关键就是：切点定义了哪些连接点会得到通知 ​ 6. aop原理 spring用代理类包裹切面，把他们织入到Spring管理的bean中。也就是说代理类伪装成目标类，它会截取对目标类中方法的调用，让调用者对目标类的调用都先变成调用伪装类，伪装类中就先执行了切面，再把调用转发给真正的目标bean。 现在可以自己想一想，怎么搞出来这个伪装类，才不会被调用者发现（过JVM的检查，JAVA是强类型检查，哪里都要检查类型）。 1.实现和目标类相同的接口，我也实现和你一样的接口，反正上层都是接口级别的调用，这样我就伪装成了和目标类一样的类（实现了同一接口，咱是兄弟了），也就逃过了类型检查，到java运行期的时候，利用多态的后期绑定（所以spring采用运行时），伪装类（代理类）就变成了接口的真正实现，而他里面包裹了真实的那个目标类，最后实现具体功能的还是目标类，只不过伪装类在之前干了点事情（写日志，安全检查，事物等）。 这就好比，一个人让你办件事，每次这个时候，你弟弟就会先出来，当然他分不出来了，以为是你，你这个弟弟虽然办不了这事，但是他知道你能办，所以就答应下来了，并且收了点礼物（写日志），收完礼物了，给把事给人家办了啊，所以你弟弟又找你这个哥哥来了，最后把这是办了的还是你自己。但是你自己并不知道你弟弟已经收礼物了，你只是专心把这件事情做好。 顺着这个思路想，要是本身这个类就没实现一个接口呢，你怎么伪装我，我就压根没有机会让你搞出这个双胞胎的弟弟，那么就用第2种代理方式，创建一个目标类的子类，生个儿子，让儿子伪装我 2.生成子类调用，这次用子类来做为伪装类，当然这样也能逃过JVM的强类型检查，我继承的吗，当然查不出来了，子类重写了目标类的所有方法，当然在这些重写的方法中，不仅实现了目标类的功能，还在这些功能之前，实现了一些其他的（写日志，安全检查，事物等）。 这次的对比就是，儿子先从爸爸那把本事都学会了，所有人都找儿子办事情，但是儿子每次办和爸爸同样的事之前，都要收点小礼物（写日志），然后才去办真正的事。当然爸爸是不知道儿子这么干的了。这里就有件事情要说，某些本事是爸爸独有的(final的)，儿子学不了，学不了就办不了这件事，办不了这个事情，自然就不能收人家礼了。 前一种兄弟模式，spring会使用JDK的java.lang.reflect.Proxy类，它允许Spring动态生成一个新类来实现必要的接口，织入通知，并且把对这些接口的任何调用都转发到目标类。 后一种父子模式，spring使用CGLIB库生成目标类的一个子类，在创建这个子类的时候，spring织入通知，并且把对这个子类的调用委托到目标类。 相比之下，还是兄弟模式好些，他能更好的实现松耦合，尤其在今天都高喊着面向接口编程的情况下，父子模式只是在没有实现接口的时候，也能织入通知，应当做一种例外。 ————————————————AOP部分原文链接："},{"title":"数据连接池注解学习入门","date":"2022-03-19T14:17:18.000Z","url":"/2022/03/19/%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/","tags":[["Spring","/tags/Spring/"]],"categories":[["Spring","/categories/Spring/"],["Spring注解驱动学习","/categories/Spring/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/"]],"content":"数据源的手动创建 @Configuration @ComponentScan @Import 读取jdbc.properties配置文件创建连接池 @PropertySource @value 创建C3P0连接池@Bean 测试加载核心配置类创建Spring容器"},{"title":"加载配置文件","date":"2022-03-19T13:56:55.000Z","url":"/2022/03/19/%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","tags":[["Spring","/tags/Spring/"]],"categories":[["Spring","/categories/Spring/"],["Spring注解驱动学习","/categories/Spring/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/"]],"content":"​ IDEA: 如 jdbc.properties配置文件存在resource资源文件夹里 方法一： 方法二： PropertySource注解:引入jdbc属性资源文件"},{"title":"对IoC(控制反转)和DI(依赖注入)的理解","date":"2022-03-19T13:34:39.000Z","url":"/2022/03/19/%E5%AF%B9IoC-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC-%E5%92%8CDI-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-%E7%9A%84%E7%90%86%E8%A7%A3/","tags":[["Spring","/tags/Spring/"]],"categories":[["Spring","/categories/Spring/"],["理论理解","/categories/Spring/%E7%90%86%E8%AE%BA%E7%90%86%E8%A7%A3/"]],"content":"一、IoC是什么​ IOC的作用：降低程序之间的耦合（依赖关系） 概念：依赖关系的管理交给spring维护，在当前类需要用到其他类的对象，由spring为我们提供，只需在配置文件中说明关系的维护； Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。 ​ 在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下： ● 谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；**谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。 ​ ● 为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。 二、DI依赖注入 DI—Dependency Injection，即“依赖注入”：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。 理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下： ●谁依赖于谁：当然是应用程序依赖于IoC容器； ●为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源； ●谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象； ●注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。 IoC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。 看过很多对Spring的Ioc理解的文章，好多人对Ioc和DI的解释都晦涩难懂，反正就是一种说不清，道不明的感觉，读完之后依然是一头雾水，感觉就是开涛这位技术牛人写得特别通俗易懂，他清楚地解释了IoC(控制反转) 和DI(依赖注入)中的每一个字，读完之后给人一种豁然开朗的感觉。我相信对于初学Spring框架的人对Ioc的理解应该是有很大帮助的。 三、我对IoC(控制反转)和DI(依赖注入)的理解 在平时的java应用开发中，我们要实现某一个功能或者说是完成某个业务逻辑时至少需要两个或以上的对象来协作完成，在没有使用Spring的时候，每个对象在需要使用他的合作对象时，自己均要使用像new object() 这样的语法来将合作对象创建出来，这个合作对象是由自己主动创建出来的，创建合作对象的主动权在自己手上，自己需要哪个合作对象，就主动去创建，创建合作对象的主动权和创建时机是由自己把控的，而这样就会使得对象间的耦合度高了，A对象需要使用合作对象B来共同完成一件事，A要使用B，那么A就对B产生了依赖，也就是A和B之间存在一种耦合关系，并且是紧密耦合在一起，而使用了Spring之后就不一样了，创建合作对象B的工作是由Spring来做的，Spring创建好B对象，然后存储到一个容器里面，当A对象需要使用B对象时，Spring就从存放对象的那个容器里面取出A要使用的那个B对象，然后交给A对象使用，至于Spring是如何创建那个对象，以及什么时候创建好对象的，A对象不需要关心这些细节问题(你是什么时候生的，怎么生出来的我可不关心，能帮我干活就行)，A得到Spring给我们的对象之后，两个人一起协作完成要完成的工作即可。 所以控制反转IoC(Inversion of Control)是说创建对象的控制权进行转移，以前创建对象的主动权和创建时机是由自己把控的，而现在这种权力转移到第三方，比如转移交给了IoC容器，它就是一个专门用来创建对象的工厂，你要什么对象，它就给你什么对象，有了 IoC容器，依赖关系就变了，原先的依赖关系就没了，它们都依赖IoC容器了，通过IoC容器来建立它们之间的关系。 这是我对Spring的IoC**(控制反转)的理解。DI(依赖注入)其实就是IOC的另外一种说法，DI是由Martin Fowler 在2004年初的一篇论文中首次提出的。他总结：控制的什么被反转了？就是：获得依赖对象的方式反转了。**"},{"title":"使用@Bean注解","date":"2022-03-19T13:31:59.000Z","url":"/2022/03/19/%E4%BD%BF%E7%94%A8-Bean-%E6%B3%A8%E8%A7%A3/","tags":[["Spring注解","/tags/Spring%E6%B3%A8%E8%A7%A3/"]],"categories":[["Spring","/categories/Spring/"],["Spring注解驱动学习","/categories/Spring/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/"]],"content":"@Bean是方法级注解，您可以在@Configuration注解的类或@Component注解 的类中使用@Bean注解。 ​ 要声明 bean，可以使用@Bean注解 对方法进行 注解。您可以使用此方法在指定为该方法的返回值的类型的ApplicationContext内注册 bean 定义。默认情况下，Bean 名称与方法名称相同。 ​ bean 名称以小写字母开头，并从那里用驼峰式大小写。这样的名称的示例包括accountManager，accountService，userDao，loginController等。 以下示例显示了使用@Bean注解的方法声明： 前面的配置与下面的 Spring 的XML文件相关配置完全等效： ​ 即：transferService -&gt; com.acme.TransferServiceImpl ​ 这两个声明使一个名为transferService的 bean 在ApplicationContext中可用，并绑定到TransferServiceImpl类型的对象实例 自定义 Bean 命名 ​ 默认情况下，配置类使用@Bean方法的名称作为结果 bean 的名称。但是，可以使用name属性覆盖此功能，如以下示例所示： ​ 有时希望为单个 bean 提供多个名称，否则称为 bean 别名。 @Bean注解的name属性为此目的接受一个 String 数组。以下示例说明如何为 bean 设置多个别名： "},{"title":"“Git报错解决errno 10054”","date":"2022-03-19T08:02:55.000Z","url":"/2022/03/19/Git%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/","tags":[["Git报错","/tags/Git%E6%8A%A5%E9%94%99/"]],"categories":[["报错信息合集","/categories/%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF%E5%90%88%E9%9B%86/"]],"content":"Git报错解决 : Connection was reset, errno 10054“造成这个错误很有可能是网络不稳定，连接超时导致的” 以执行下面的命令。 打开Git命令页面，执行git命令脚本：修改设置，解除ssl验证 git config –global http.sslVerify false” "},{"title":"spring注解学习-01","date":"2022-03-19T02:15:35.000Z","url":"/2022/03/19/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0-01/","tags":[["Spring注解驱动","/tags/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8/"]],"categories":[["Spring","/categories/Spring/"],["Spring注解驱动学习","/categories/Spring/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/"]],"content":"Spring注解开发 注解 说明 @Component 使用在类上用于实例化Bean @Controller 使用在web层类上用于实例化Bean @Service 使用在service层类上用于实例化Bean @Repository 使用在dao层类上用于实例化Bean @Autowired 使用在字段上用于根据类型依赖注入 @Qualifier 结合@Autowired一起使用用于根据名称进行依赖注入 @Resource 相当于@Autowired+@Qualifier，按照名称进行注入 @Value 注入普通属性 @Scope 标注Bean的作用范围 @PostConstruct 使用在方法上标注该方法是Bean的初始化方法 @PreDestroy 使用在方法上标注该方法是Bean的销毁方法 一、@Configuration@Configuration是类级别的注解，指示对象是 Bean 定义的源。 ​ @Bean注解用于表示一个方法实例化、配置和初始化一个由 Spring IoC 容器管理的新对象。最常与@Configuration 一起使用。 实体类 配置类 测试 测试结果 注：可根据过滤规则，过滤指定的组件（这里指定的是Controller组件） 二、懒加载@Lazy：如果我们想要 Spring 在启动的时候延迟加载 bean，即在调用某个 bean 的时候再去初始化，那么就可以使用 @Lazy 注解。 单实例bean，默认在容器启动的时候创建对象 懒加载：容器启动不创建对象，第一次使用才获取Bean创建对象，并初始化 测试结果：没加懒加载的运行结果： 加了懒加载的运行结果： ​ "},{"title":"客户端表单提交及接收后台json格式数据content-type问题","date":"2022-03-17T16:22:54.000Z","url":"/2022/03/18/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4%E5%8F%8A%E6%8E%A5%E6%94%B6%E5%90%8E%E5%8F%B0json%E6%A0%BC%E5%BC%8F%E6%95%B0%E6%8D%AEcontent-type%E9%97%AE%E9%A2%98/","tags":[["报错信息","/tags/%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF/"]],"categories":[["报错信息合集","/categories/%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF%E5%90%88%E9%9B%86/"]],"content":"org.springframework.web.HttpMediaTypeNotSupportedException: Content type ‘application&#x2F;json;charset&#x3D;UTF-8’ not supported或其他Content type不支持处理 记录在ssm项目遇到的报错信息，以积累经验 报错原因：​ form表单的post编码是content-type:application&#x2F;x-www-form-urlencoded， ​ 我觉得吧，一直报错不支持json格式就是因为后台返回的数据跟客户端的请求头content-type格式不一致导致的，因为原本是用form标签，一直改不了它接收json的格式，而我们需要接收的是json格式的数据，就需要‘application&#x2F;json’格式的content-type，所有就一直报415的错。 解决方法：​ 后来我换条思路，干脆不要form标签了，直接用div标签做成跟原本一样的，button按钮提交，结合ajax这样，后来浏览器里的content-type不再是application&#x2F;x-www-form-urlencoded，json格式的数据也成功接收到，因此问题就解决了。 源码： 运行结果： 后台获取到的数据（测试） 登录成功跳转其他页面 "},{"title":"Hello World","date":"2022-03-09T04:55:52.786Z","url":"/2022/03/09/hello-world/","categories":[["test","/categories/test/"]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 喵呼呼o(&#x3D;•ェ•&#x3D;)m 成功啦o(￣▽￣)ブ 有危险Σ(っ °Д °;)っ 有消息(・∀・(・∀・(・∀・*) 当心哦≧ ﹏ ≦ 这是红色字体 这是绿色字体 这是黄色字体 这是蓝色字体 为字体加颜色 抽屉式代码展示 开始测试Create a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment hexo cl &amp;&amp; hexo g &amp;&amp; hexo d"}]