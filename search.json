[{"title":"加载配置文件","date":"2022-03-19T13:56:55.000Z","url":"/2022/03/19/%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","tags":[["Spring","/tags/Spring/"]],"categories":[["Spring, Spring注解驱动学习]","/categories/Spring-Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/"]],"content":"​ IDEA: 如 jdbc.properties配置文件存在resource资源文件夹里 方法一： 方法二： PropertySource注解:引入jdbc属性资源文件"},{"title":"对IoC(控制反转)和DI(依赖注入)的理解","date":"2022-03-19T13:34:39.000Z","url":"/2022/03/19/%E5%AF%B9IoC-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC-%E5%92%8CDI-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-%E7%9A%84%E7%90%86%E8%A7%A3/","tags":[["Spring","/tags/Spring/"]],"categories":[["Spring","/categories/Spring/"],["理论理解","/categories/Spring/%E7%90%86%E8%AE%BA%E7%90%86%E8%A7%A3/"]],"content":"一、IoC是什么​ IOC的作用：降低程序之间的耦合（依赖关系） 概念：依赖关系的管理交给spring维护，在当前类需要用到其他类的对象，由spring为我们提供，只需在配置文件中说明关系的维护； Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。 ​ 在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下： ● 谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；**谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。 ​ ● 为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。 二、DI依赖注入 DI—Dependency Injection，即“依赖注入”：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。 理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下： ●谁依赖于谁：当然是应用程序依赖于IoC容器； ●为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源； ●谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象； ●注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。 IoC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。 看过很多对Spring的Ioc理解的文章，好多人对Ioc和DI的解释都晦涩难懂，反正就是一种说不清，道不明的感觉，读完之后依然是一头雾水，感觉就是开涛这位技术牛人写得特别通俗易懂，他清楚地解释了IoC(控制反转) 和DI(依赖注入)中的每一个字，读完之后给人一种豁然开朗的感觉。我相信对于初学Spring框架的人对Ioc的理解应该是有很大帮助的。 三、我对IoC(控制反转)和DI(依赖注入)的理解 在平时的java应用开发中，我们要实现某一个功能或者说是完成某个业务逻辑时至少需要两个或以上的对象来协作完成，在没有使用Spring的时候，每个对象在需要使用他的合作对象时，自己均要使用像new object() 这样的语法来将合作对象创建出来，这个合作对象是由自己主动创建出来的，创建合作对象的主动权在自己手上，自己需要哪个合作对象，就主动去创建，创建合作对象的主动权和创建时机是由自己把控的，而这样就会使得对象间的耦合度高了，A对象需要使用合作对象B来共同完成一件事，A要使用B，那么A就对B产生了依赖，也就是A和B之间存在一种耦合关系，并且是紧密耦合在一起，而使用了Spring之后就不一样了，创建合作对象B的工作是由Spring来做的，Spring创建好B对象，然后存储到一个容器里面，当A对象需要使用B对象时，Spring就从存放对象的那个容器里面取出A要使用的那个B对象，然后交给A对象使用，至于Spring是如何创建那个对象，以及什么时候创建好对象的，A对象不需要关心这些细节问题(你是什么时候生的，怎么生出来的我可不关心，能帮我干活就行)，A得到Spring给我们的对象之后，两个人一起协作完成要完成的工作即可。 所以控制反转IoC(Inversion of Control)是说创建对象的控制权进行转移，以前创建对象的主动权和创建时机是由自己把控的，而现在这种权力转移到第三方，比如转移交给了IoC容器，它就是一个专门用来创建对象的工厂，你要什么对象，它就给你什么对象，有了 IoC容器，依赖关系就变了，原先的依赖关系就没了，它们都依赖IoC容器了，通过IoC容器来建立它们之间的关系。 这是我对Spring的IoC**(控制反转)的理解。DI(依赖注入)其实就是IOC的另外一种说法，DI是由Martin Fowler 在2004年初的一篇论文中首次提出的。他总结：控制的什么被反转了？就是：获得依赖对象的方式反转了。**"},{"title":"使用@Bean注解","date":"2022-03-19T13:31:59.000Z","url":"/2022/03/19/%E4%BD%BF%E7%94%A8-Bean-%E6%B3%A8%E8%A7%A3/","tags":[["Spring注解","/tags/Spring%E6%B3%A8%E8%A7%A3/"]],"categories":[["Spring","/categories/Spring/"],["Spring注解驱动学习","/categories/Spring/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/"]],"content":"@Bean是方法级注解，您可以在@Configuration注解的类或@Component注解 的类中使用@Bean注解。 ​ 要声明 bean，可以使用@Bean注解 对方法进行 注解。您可以使用此方法在指定为该方法的返回值的类型的ApplicationContext内注册 bean 定义。默认情况下，Bean 名称与方法名称相同。 ​ bean 名称以小写字母开头，并从那里用驼峰式大小写。这样的名称的示例包括accountManager，accountService，userDao，loginController等。 以下示例显示了使用@Bean注解的方法声明： 前面的配置与下面的 Spring 的XML文件相关配置完全等效： ​ 即：transferService -&gt; com.acme.TransferServiceImpl ​ 这两个声明使一个名为transferService的 bean 在ApplicationContext中可用，并绑定到TransferServiceImpl类型的对象实例 自定义 Bean 命名 ​ 默认情况下，配置类使用@Bean方法的名称作为结果 bean 的名称。但是，可以使用name属性覆盖此功能，如以下示例所示： ​ 有时希望为单个 bean 提供多个名称，否则称为 bean 别名。 @Bean注解的name属性为此目的接受一个 String 数组。以下示例说明如何为 bean 设置多个别名： "},{"title":"“Git报错解决errno 10054”","date":"2022-03-19T08:02:55.000Z","url":"/2022/03/19/Git%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/","tags":[["Git报错","/tags/Git%E6%8A%A5%E9%94%99/"]],"categories":[["报错信息合集","/categories/%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF%E5%90%88%E9%9B%86/"]],"content":"Git报错解决 : Connection was reset, errno 10054“造成这个错误很有可能是网络不稳定，连接超时导致的” 以执行下面的命令。 打开Git命令页面，执行git命令脚本：修改设置，解除ssl验证 git config –global http.sslVerify false” "},{"title":"spring注解学习-01","date":"2022-03-19T02:15:35.000Z","url":"/2022/03/19/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0-01/","tags":[["Spring注解驱动","/tags/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8/"]],"categories":[["Spring","/categories/Spring/"],["Spring注解驱动学习","/categories/Spring/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/"]],"content":"Spring注解开发 注解 说明 @Component 使用在类上用于实例化Bean @Controller 使用在web层类上用于实例化Bean @Service 使用在service层类上用于实例化Bean @Repository 使用在dao层类上用于实例化Bean @Autowired 使用在字段上用于根据类型依赖注入 @Qualifier 结合@Autowired一起使用用于根据名称进行依赖注入 @Resource 相当于@Autowired+@Qualifier，按照名称进行注入 @Value 注入普通属性 @Scope 标注Bean的作用范围 @PostConstruct 使用在方法上标注该方法是Bean的初始化方法 @PreDestroy 使用在方法上标注该方法是Bean的销毁方法 一、@Configuration@Configuration是类级别的注解，指示对象是 Bean 定义的源。 ​ @Bean注解用于表示一个方法实例化、配置和初始化一个由 Spring IoC 容器管理的新对象。最常与@Configuration 一起使用。 实体类 配置类 测试 测试结果 注：可根据过滤规则，过滤指定的组件（这里指定的是Controller组件） 二、懒加载@Lazy：如果我们想要 Spring 在启动的时候延迟加载 bean，即在调用某个 bean 的时候再去初始化，那么就可以使用 @Lazy 注解。 单实例bean，默认在容器启动的时候创建对象 懒加载：容器启动不创建对象，第一次使用才获取Bean创建对象，并初始化 测试结果：没加懒加载的运行结果： 加了懒加载的运行结果： ​ "},{"title":"客户端表单提交及接收后台json格式数据content-type问题","date":"2022-03-17T16:22:54.000Z","url":"/2022/03/18/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4%E5%8F%8A%E6%8E%A5%E6%94%B6%E5%90%8E%E5%8F%B0json%E6%A0%BC%E5%BC%8F%E6%95%B0%E6%8D%AEcontent-type%E9%97%AE%E9%A2%98/","tags":[["报错信息","/tags/%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF/"]],"categories":[["报错信息合集","/categories/%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF%E5%90%88%E9%9B%86/"]],"content":"org.springframework.web.HttpMediaTypeNotSupportedException: Content type ‘application&#x2F;json;charset&#x3D;UTF-8’ not supported或其他Content type不支持处理 记录在ssm项目遇到的报错信息，以积累经验 报错原因：​ form表单的post编码是content-type:application&#x2F;x-www-form-urlencoded， ​ 我觉得吧，一直报错不支持json格式就是因为后台返回的数据跟客户端的请求头content-type格式不一致导致的，因为原本是用form标签，一直改不了它接收json的格式，而我们需要接收的是json格式的数据，就需要‘application&#x2F;json’格式的content-type，所有就一直报415的错。 解决方法：​ 后来我换条思路，干脆不要form标签了，直接用div标签做成跟原本一样的，button按钮提交，结合ajax这样，后来浏览器里的content-type不再是application&#x2F;x-www-form-urlencoded，json格式的数据也成功接收到，因此问题就解决了。 源码： 运行结果： 后台获取到的数据（测试） 登录成功跳转其他页面 "},{"title":"Hello World","date":"2022-03-09T04:55:52.786Z","url":"/2022/03/09/hello-world/","categories":[["test","/categories/test/"]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 喵呼呼o(&#x3D;•ェ•&#x3D;)m 成功啦o(￣▽￣)ブ 有危险Σ(っ °Д °;)っ 有消息(・∀・(・∀・(・∀・*) 当心哦≧ ﹏ ≦ 开始测试Create a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"}]